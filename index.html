<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>马年祝福 · 手势粒子成语 · 红包开封 · 烟花背景</title>

  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <script type="importmap-shim">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --gold:#d4af37; --red:#b11226; --panel: rgba(10,10,12,.58);
      --panel2: rgba(4,6,9,.42); --line: rgba(212,175,55,.35);
      --text: rgba(255,255,255,.92); --muted: rgba(255,255,255,.65);
    }
    html,body{height:100%;margin:0;background:#040405;color:var(--text);font-family:ui-sans-serif,system-ui;overflow:hidden;}
    #app{position:fixed;inset:0;}
    canvas#gl{position:absolute;inset:0;width:100%;height:100%;display:block;touch-action:none;}
    .cinema-vignette{position:absolute;inset:0;pointer-events:none;
      background:radial-gradient(120% 120% at 50% 45%, rgba(0,0,0,0) 42%, rgba(0,0,0,.62) 100%),
                 radial-gradient(90% 70% at 50% 0%, rgba(212,175,55,.14) 0%, rgba(0,0,0,0) 60%);
      opacity:.95;}
    .hud{position:absolute;left:12px;right:12px;top:12px;display:flex;gap:10px;align-items:flex-start;pointer-events:none;}
    .panel{pointer-events:auto;flex:1 1 auto;max-width:920px;padding:12px;border:1px solid var(--line);border-radius:14px;
      background:linear-gradient(180deg,var(--panel) 0%,var(--panel2) 100%);backdrop-filter: blur(10px);box-shadow:0 14px 40px rgba(0,0,0,.45);}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .brand{display:flex;gap:10px;align-items:center;min-width:300px;}
    .badge{width:12px;height:12px;border-radius:999px;background:var(--gold);box-shadow:0 0 0 2px rgba(212,175,55,.18),0 0 18px rgba(212,175,55,.45);}
    .title{font-weight:800;font-size:14px;letter-spacing:.3px;}
    .subtitle{font-size:12px;color:var(--muted);margin-top:2px;}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-left:auto;}
    button{pointer-events:auto;appearance:none;border:1px solid rgba(212,175,55,.38);color:var(--text);
      background:linear-gradient(180deg, rgba(177,18,38,.35), rgba(0,0,0,.22));
      border-radius:12px;padding:10px 12px;font-size:12px;font-weight:800;cursor:pointer;user-select:none;}
    button.secondary{border-color: rgba(255,255,255,.14);background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.18));}
    .status{margin-left:auto;font-size:12px;color:rgba(255,255,255,.70);display:flex;align-items:center;gap:8px;}
    .led{width:8px;height:8px;border-radius:999px;background:rgba(255,255,255,.18);box-shadow:0 0 0 2px rgba(255,255,255,.06);}
    .led.on{background:var(--gold);box-shadow:0 0 0 2px rgba(212,175,55,.16),0 0 16px rgba(212,175,55,.55);}

    .focusOverlay{position:absolute;inset:0;display:flex;align-items:flex-end;justify-content:center;padding:16px 12px 22px;pointer-events:none;
      opacity:0;transform:translate3d(0,10px,0);transition:opacity .25s ease, transform .25s ease;}
    .focusOverlay.show{opacity:1;transform:translate3d(0,0,0);}
    .focusCard{pointer-events:auto;width:min(860px, calc(100vw - 24px));border-radius:18px;border:1px solid rgba(212,175,55,.45);
      background:linear-gradient(180deg, rgba(0,0,0,.55), rgba(8,10,12,.66));backdrop-filter:blur(12px);
      box-shadow:0 22px 70px rgba(0,0,0,.62);padding:14px;position:relative;overflow:hidden;}
    .focusTop{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;position:relative;}
    .packet{width:150px;height:190px;border-radius:16px;background:linear-gradient(180deg, rgba(177,18,38,.98), rgba(120,8,22,.98));
      border:1px solid rgba(212,175,55,.55);box-shadow:0 18px 55px rgba(0,0,0,.6);position:relative;overflow:hidden;transform-origin:50% 0%;}
    .packet .seal{position:absolute;left:50%;top:54%;width:62px;height:62px;transform:translate(-50%,-50%);border-radius:999px;
      background:radial-gradient(circle at 30% 30%, rgba(255,245,220,.95), rgba(212,175,55,.92) 60%, rgba(90,60,10,.85) 100%);
      box-shadow:0 0 0 2px rgba(212,175,55,.20),0 0 26px rgba(212,175,55,.45);}
    .packet .lid{position:absolute;left:0;top:0;width:100%;height:52%;background:linear-gradient(180deg, rgba(215,30,55,.98), rgba(140,10,30,.98));
      border-bottom:1px solid rgba(212,175,55,.35);transform-origin:50% 100%;transform:rotateX(0deg);}
    .packet.open .lid{animation:openLid .55s ease forwards;}
    @keyframes openLid{0%{transform:rotateX(0deg);}100%{transform:rotateX(-125deg);}}
    .focusTextWrap{flex:1 1 320px;min-width:260px;}
    .focusTitle{margin:0;font-size:15px;letter-spacing:.5px;font-weight:900;}
    .focusLine{margin:8px 0 0;font-size:14px;line-height:1.6;color:rgba(255,255,255,.88);white-space:pre-wrap;}
    .videoWrap{margin-top:12px;border-radius:16px;overflow:hidden;border:1px solid rgba(255,255,255,.12);box-shadow:0 16px 46px rgba(0,0,0,.55);}
    .videoWrap video{width:100%;height:auto;display:block;background:#000;}
    video#cam{position:absolute;right:12px;bottom:12px;width:120px;height:160px;opacity:0;pointer-events:none;}
  </style>
</head>

<body>
<div id="app">
  <canvas id="gl"></canvas>
  <div class="cinema-vignette"></div>

  <div class="hud">
    <div class="panel">
      <div class="row">
        <div class="brand">
          <span class="badge"></span>
          <div>
            <div class="title">马年祝福 · 手势粒子成语 · 红包开封 · 烟花背景</div>
            <div class="subtitle">Three.js / MediaPipe Hands / Bloom</div>
          </div>
        </div>

        <div class="controls">
          <button id="btnStart">启用手势识别</button>
          <button id="btnReset" class="secondary">重置</button>
        </div>

        <div class="status">
          <span id="led" class="led"></span>
          <span id="statusText">已加载：凝聚态（稳定成语 + 红包环绕）</span>
        </div>
      </div>
    </div>
  </div>

  <div id="focusOverlay" class="focusOverlay">
    <div class="focusCard">
      <div class="focusTop">
        <div id="packet" class="packet">
          <div class="lid"></div>
          <div class="seal"></div>
        </div>
        <div class="focusTextWrap">
          <h3 id="focusTitle" class="focusTitle">红包到 · 好运到</h3>
          <div id="focusText" class="focusLine"></div>
        </div>
      </div>
      <div class="videoWrap">
        <video id="horseVideo" playsinline muted loop></video>
      </div>
    </div>
  </div>

  <video id="cam" playsinline></video>
</div>

<script type="module-shim">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

const IDIOMS = ["马到成功","龙马精神","一马当先","万马奔腾","马上发财","天马行空","马跃钱程","马年大吉"];
const HORSE_VIDEOS = ["assets/videos/horse1.mp4","assets/videos/horse2.mp4","assets/videos/horse3.mp4","assets/videos/horse4.mp4"];

// ✅ 你的 WebM 路径
const HORSE_RUN_URL = "assets/video/horse.webm";

const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const DPR_CAP = IS_MOBILE ? 1.15 : 1.75;

// ✅ Bloom 降分辨率渲染（大幅减负，视频更顺畅）
const BLOOM_SCALE = IS_MOBILE ? 0.55 : 0.70;

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp  = (a,b,t)=>a+(b-a)*t;
const damp = (current, target, lambda, dt) => {
  const t = 1 - Math.exp(-lambda * dt);
  return current + (target - current) * t;
};

const canvas = document.getElementById("gl");
const statusText = document.getElementById("statusText");
const led = document.getElementById("led");
const btnStart = document.getElementById("btnStart");
const btnReset = document.getElementById("btnReset");
const videoEl = document.getElementById("cam");

const focusOverlay = document.getElementById("focusOverlay");
const focusTitleEl = document.getElementById("focusTitle");
const focusTextEl = document.getElementById("focusText");
const packetEl = document.getElementById("packet");
const horseVideo = document.getElementById("horseVideo");

function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

// ---------------------------
// Three 基础
// ---------------------------
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:"high-performance" });
renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio || 1));
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.06;

const scene = new THREE.Scene();
scene.background = new THREE.Color("#030304");

const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 220);
camera.position.set(0, 2.3, 10.4);

scene.add(new THREE.AmbientLight(0xffffff, 0.18));
const key = new THREE.DirectionalLight(0xfff2d6, 0.95);
key.position.set(6, 9, 6);
scene.add(key);

const goldPoint = new THREE.PointLight(0xd4af37, 1.15, 28, 2);
goldPoint.position.set(0, 5.2, 3.2);
scene.add(goldPoint);

// ---------------------------
// Bloom（低分辨率）+ Final（全分辨率）
// ---------------------------
const BLOOM_LAYER = 1;

const bloomComposer = new EffectComposer(renderer);
bloomComposer.setPixelRatio(Math.min(renderer.getPixelRatio(), renderer.getPixelRatio() * BLOOM_SCALE));
bloomComposer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.95, 0.62, 0.18);
bloomComposer.addPass(bloomPass);

const finalComposer = new EffectComposer(renderer);
finalComposer.setPixelRatio(renderer.getPixelRatio());
finalComposer.addPass(new RenderPass(scene, camera));

const bloomMixPass = new ShaderPass(
  new THREE.ShaderMaterial({
    uniforms: {
      baseTexture: { value: null },
      bloomTexture: { value: bloomComposer.renderTarget2.texture },
      uBloomIntensity: { value: 0.95 }
    },
    vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
    fragmentShader: `
      uniform sampler2D baseTexture;
      uniform sampler2D bloomTexture;
      uniform float uBloomIntensity;
      varying vec2 vUv;
      void main(){
        vec4 base = texture2D(baseTexture, vUv);
        vec4 bloom = texture2D(bloomTexture, vUv);
        gl_FragColor = base + bloom * uBloomIntensity;
      }
    `
  }),
  "baseTexture"
);
finalComposer.addPass(bloomMixPass);
finalComposer.addPass(new OutputPass());

// ---------------------------
// Mode / 过渡
// ---------------------------
const Mode = { MERGE:"MERGE", SCATTER:"SCATTER", FOCUS:"FOCUS" };
let mode = Mode.MERGE;
let mix = 0, targetMix = 0;
let focus = 0, targetFocus = 0;

function showFocusOverlay(){ focusOverlay.classList.add("show"); }
function hideFocusOverlay(){ focusOverlay.classList.remove("show"); packetEl.classList.remove("open"); }

function setMode(next){
  if(mode === next) return;
  mode = next;
  if(mode === Mode.MERGE){
    targetMix = 0; targetFocus = 0;
    hideFocusOverlay();
  }else if(mode === Mode.SCATTER){
    targetMix = 1; targetFocus = 0;
    hideFocusOverlay();
  }else{
    targetMix = 1; targetFocus = 1;
    showFocusOverlay();
  }
  setHorseScatterVisible(mode === Mode.SCATTER);
}

// ---------------------------
// ✅ WebM 奔跑马：VideoTexture（稳定渲染，不闪）
// ---------------------------
const horseRunVideo = document.createElement("video");
horseRunVideo.src = HORSE_RUN_URL;
horseRunVideo.muted = true;
horseRunVideo.loop = true;
horseRunVideo.playsInline = true;
horseRunVideo.preload = "auto";
horseRunVideo.crossOrigin = "anonymous";

// ✅ 只要 ready 才显示，避免黑帧/闪
let horseReady = false;
horseRunVideo.addEventListener("loadeddata", ()=>{ horseReady = true; }, { once:false });
horseRunVideo.addEventListener("canplay", ()=>{ horseReady = true; }, { once:false });

const horseRunTex = new THREE.VideoTexture(horseRunVideo);
horseRunTex.colorSpace = THREE.SRGBColorSpace;
horseRunTex.minFilter = THREE.LinearFilter;
horseRunTex.magFilter = THREE.LinearFilter;
horseRunTex.generateMipmaps = false;

const horseGroup = new THREE.Group();
horseGroup.visible = false;
scene.add(horseGroup);

const horseMat = new THREE.MeshBasicMaterial({
  map: horseRunTex,
  transparent: true,
  depthWrite: false,
  depthTest: false,        // ✅ 避免与大量透明粒子排序冲突（关键）
  toneMapped: false,
  opacity: 1.0
});

const horsePlane = new THREE.Mesh(new THREE.PlaneGeometry(6.2, 3.6), horseMat);

// ✅ 强制最后画（关键：不闪烁）
horsePlane.renderOrder = 100000;

// ✅ 同时在 Base + Bloom 渲染（不再只靠 Bloom 显示，避免忽隐忽现）
horsePlane.layers.enable(0);
horsePlane.layers.enable(BLOOM_LAYER);

horseGroup.add(horsePlane);
horseGroup.position.set(0, 2.25, 0.55);

function updateHorseBillboard(){
  horsePlane.quaternion.copy(camera.quaternion);
}
function updateHorseMotion(t){
  horseGroup.position.y = 2.25 + Math.sin(t * 6.0) * 0.05;
  horseGroup.position.x = Math.sin(t * 2.2) * 0.03;
}

async function warmupVideo(v){
  // ✅ 预热：用户点击“启用手势”时执行（能显著减少首次卡顿）
  try{
    await v.play();
    v.pause();
  }catch(e){}
}

function setHorseScatterVisible(v){
  horseGroup.visible = v;

  if(v){
    // ✅ 只有 ready 才显示，不 ready 时先隐藏，防止闪
    if(!horseReady && horseRunVideo.readyState < 2){
      horseGroup.visible = false;
    }
    horseRunVideo.play().catch(()=>{});
  }else{
    horseRunVideo.pause();
  }
}

// ---------------------------
// 银河环（大量星星）
// ---------------------------
function makeDotTexture(){
  const c = document.createElement("canvas");
  c.width = 128; c.height = 128;
  const ctx = c.getContext("2d");
  const g = ctx.createRadialGradient(64,64,0,64,64,64);
  g.addColorStop(0, "rgba(255,255,255,1)");
  g.addColorStop(0.25, "rgba(255,255,255,0.85)");
  g.addColorStop(0.55, "rgba(255,255,255,0.25)");
  g.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = g;
  ctx.beginPath(); ctx.arc(64,64,62,0,Math.PI*2); ctx.fill();
  const tex = new THREE.CanvasTexture(c);
  tex.colorSpace = THREE.SRGBColorSpace;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  tex.generateMipmaps = false;
  return tex;
}
const DOT_TEX = makeDotTexture();

class GalaxyRing {
  constructor(count = (IS_MOBILE ? 8000 : 14000)){
    this.count = count;
    this.pos = new Float32Array(count*3);
    this.seed= new Float32Array(count);
    this.baseR = new Float32Array(count);
    this.baseH = new Float32Array(count);
    this.baseA = new Float32Array(count);

    for(let i=0;i<count;i++){
      this.seed[i] = Math.random();
      this.baseR[i] = lerp(4.8, 8.6, Math.pow(Math.random(), 0.55));
      this.baseH[i] = (Math.random()-0.5) * lerp(0.25, 1.10, Math.random());
      this.baseA[i] = Math.random() * Math.PI * 2;
    }

    this.geo = new THREE.BufferGeometry();
    this.geo.setAttribute("position", new THREE.BufferAttribute(this.pos,3));
    this.mat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      depthTest:false,
      blending: THREE.AdditiveBlending,
      uniforms:{ uTime:{value:0}, uOpacity:{value:0}, uMap:{value:DOT_TEX} },
      vertexShader:`
        uniform float uOpacity;
        varying float vA;
        void main(){
          vA = uOpacity;
          vec4 mv = modelViewMatrix * vec4(position,1.0);
          gl_Position = projectionMatrix * mv;
          float dist = max(0.001, -mv.z);
          gl_PointSize = clamp((1.15)*(170.0/dist), 0.55, 3.2);
        }
      `,
      fragmentShader:`
        precision highp float;
        uniform sampler2D uMap;
        uniform float uOpacity;
        varying float vA;
        void main(){
          vec4 m = texture2D(uMap, gl_PointCoord);
          if(m.a < 0.02) discard;
          vec3 warm = vec3(1.0, 0.95, 0.82);
          vec3 gold = vec3(0.86, 0.72, 0.26);
          float k = smoothstep(0.15, 0.95, m.a);
          vec3 col = mix(warm, gold, k*0.55);
          gl_FragColor = vec4(col, m.a * (0.55 + 0.45*k) * uOpacity);
        }
      `
    });

    this.points = new THREE.Points(this.geo, this.mat);
    this.points.frustumCulled = false;
    this.points.renderOrder = 90000;

    // ✅ Base + Bloom 同时画
    this.points.layers.enable(0);
    this.points.layers.enable(BLOOM_LAYER);

    scene.add(this.points);
    this.center = new THREE.Vector3(0, 2.25, 0);
  }

  update(time, dt, active01){
    this.mat.uniforms.uOpacity.value = active01;
    this.points.visible = active01 > 0.01;

    if(!this.points.visible) return;

    for(let i=0;i<this.count;i++){
      const seed = this.seed[i];
      const r = this.baseR[i];
      const h = this.baseH[i];
      const a0= this.baseA[i];
      const w = lerp(0.08, 0.22, (8.6 - r) / (8.6 - 4.8));
      const a = a0 + time * w + seed * 2.0;
      const turb = Math.sin(time*0.9 + seed*10.0) * 0.12;
      const rr = r + turb;

      this.pos[i*3+0] = this.center.x + Math.cos(a)*rr;
      this.pos[i*3+2] = this.center.z + Math.sin(a)*rr;
      this.pos[i*3+1] = this.center.y + h + Math.sin(time*0.65 + seed*12.0)*0.10;
    }
    this.geo.attributes.position.needsUpdate = true;
    this.mat.uniforms.uTime.value = time;
  }
}
const galaxy = new GalaxyRing();

// ---------------------------
// 烟花（散开态减负：自动变弱）
// ---------------------------
class Fireworks {
  constructor(maxParticles= (IS_MOBILE?4200:6500)){
    this.max=maxParticles;
    this.pos=new Float32Array(this.max*3);
    this.vel=new Float32Array(this.max*3);
    this.col=new Float32Array(this.max*3);
    this.life=new Float32Array(this.max);
    this.age =new Float32Array(this.max);
    this.active=new Uint8Array(this.max);

    this.geo=new THREE.BufferGeometry();
    this.geo.setAttribute("position", new THREE.BufferAttribute(this.pos,3));
    this.geo.setAttribute("color", new THREE.BufferAttribute(this.col,3));

    this.mat=new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, depthTest:false,
      blending:THREE.AdditiveBlending,
      uniforms:{ uOpacity:{value:1.0} },
      vertexShader:`
        attribute vec3 color;
        varying vec3 vColor;
        uniform float uOpacity;
        varying float vA;
        void main(){
          vColor=color; vA=uOpacity;
          vec4 mv=modelViewMatrix*vec4(position,1.0);
          gl_Position=projectionMatrix*mv;
          float dist=max(0.001,-mv.z);
          gl_PointSize=clamp(1.35*(170.0/dist), 0.55, 3.6);
        }
      `,
      fragmentShader:`
        precision highp float;
        varying vec3 vColor;
        varying float vA;
        void main(){
          vec2 uv=gl_PointCoord-0.5;
          float d=length(uv);
          float core=smoothstep(0.22,0.0,d);
          float halo=smoothstep(0.55,0.18,d)*0.40;
          float a=(core+halo)*vA;
          if(a<0.01) discard;
          gl_FragColor=vec4(vColor*(1.10+0.55*halo), a);
        }
      `
    });

    this.points=new THREE.Points(this.geo,this.mat);
    this.points.frustumCulled=false;
    this.points.renderOrder=1000;

    // Base + Bloom
    this.points.layers.enable(0);
    this.points.layers.enable(BLOOM_LAYER);

    scene.add(this.points);
    this.spawnTimer=0;
  }

  hsvToRgb(h,s,v){
    const i=Math.floor(h*6), f=h*6-i;
    const p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
    const m=i%6;
    const r=[v,q,p,p,t,v][m], g=[t,v,v,q,p,p][m], b=[p,p,t,v,v,q][m];
    return [r,g,b];
  }

  spawnBurst(origin, count){
    for(let n=0;n<count;n++){
      let idx=-1;
      for(let i=0;i<this.max;i++){ if(this.active[i]===0){ idx=i; break; } }
      if(idx<0) break;

      this.active[idx]=1;
      this.age[idx]=0;
      this.life[idx]=1.1+Math.random()*1.0;

      const [r,g,b]=this.hsvToRgb(Math.random(), 0.72+Math.random()*0.26, 0.82+Math.random()*0.18);
      this.col[idx*3]=r; this.col[idx*3+1]=g; this.col[idx*3+2]=b;

      this.pos[idx*3]=origin.x+(Math.random()-0.5)*0.22;
      this.pos[idx*3+1]=origin.y+(Math.random()-0.5)*0.22;
      this.pos[idx*3+2]=origin.z+(Math.random()-0.5)*0.22;

      const u=Math.random(), v2=Math.random();
      const theta=u*Math.PI*2, phi=Math.acos(2*v2-1);
      const sp=3.0+Math.random()*5.0;
      this.vel[idx*3]=Math.sin(phi)*Math.cos(theta)*sp;
      this.vel[idx*3+1]=Math.cos(phi)*sp*0.70+1.0;
      this.vel[idx*3+2]=Math.sin(phi)*Math.sin(theta)*sp;
    }
  }

  update(dt, opacity){
    this.mat.uniforms.uOpacity.value = opacity;
    this.points.visible = opacity > 0.02;
    if(!this.points.visible) return;

    this.spawnTimer -= dt;
    if(this.spawnTimer<=0){
      this.spawnTimer = 1.05 + Math.random()*1.25;
      const ox=(Math.random()-0.5)*18;
      const oy=5.2 + Math.random()*7.0;
      const oz=-14 - Math.random()*22;
      this.spawnBurst(new THREE.Vector3(ox,oy,oz), IS_MOBILE ? 95 : 150);
    }

    for(let i=0;i<this.max;i++){
      if(this.active[i]===0) continue;
      this.age[i]+=dt;
      const t=this.age[i]/this.life[i];
      if(t>=1){
        this.active[i]=0;
        this.pos[i*3]=9999; this.pos[i*3+1]=9999; this.pos[i*3+2]=9999;
        continue;
      }

      this.vel[i*3+1] -= 3.0*dt;
      const drag=Math.pow(0.983, dt*60);
      this.vel[i*3]*=drag; this.vel[i*3+1]*=drag; this.vel[i*3+2]*=drag;

      this.pos[i*3]+=this.vel[i*3]*dt;
      this.pos[i*3+1]+=this.vel[i*3+1]*dt;
      this.pos[i*3+2]+=this.vel[i*3+2]*dt;
    }
    this.geo.attributes.position.needsUpdate = true;
    this.geo.attributes.color.needsUpdate = true;
  }
}
const fireworks = new Fireworks();

// ---------------------------
// 成语粒子 + 红包（此处保留你原思路的最小必要实现）
// 重点：你当前问题是视频闪烁卡顿，所以这里不再铺满超长代码
// 你现有那段成语/红包逻辑可以继续沿用；只要保留下面两点：
// 1) 不要让视频“只在 bloom layer 显示”
// 2) bloom 降分辨率 + video depthTest=false + renderOrder
// ---------------------------

// 这里简化：仅用一个“成语牌”立方体占位，避免示例太长
const idiomHolder = new THREE.Mesh(
  new THREE.BoxGeometry(4.6, 1.4, 0.6),
  new THREE.MeshStandardMaterial({ color: 0x201014, metalness:0.25, roughness:0.35, emissive:new THREE.Color(0x0a0404) })
);
idiomHolder.position.set(0, 2.2, 0);
idiomHolder.layers.enable(0);
idiomHolder.layers.enable(BLOOM_LAYER);
scene.add(idiomHolder);

// ---------------------------
// 红包开封（保持你原交互）
// ---------------------------
async function triggerRedPacketFlow(){
  if(mode !== Mode.FOCUS) setMode(Mode.FOCUS);

  const idiom = pick(IDIOMS);
  focusTitleEl.textContent = "红包到 · 好运到";
  focusTextEl.textContent = `恭喜你抓到一个红包！\n\n${idiom}`;

  packetEl.classList.remove("open");
  void packetEl.offsetWidth;
  packetEl.classList.add("open");

  const url = pick(HORSE_VIDEOS);
  try{
    horseVideo.pause();
    horseVideo.src = url;
    horseVideo.load();
    await horseVideo.play().catch(()=>{});
  }catch(e){}
}

// ---------------------------
// 手势（保留你规则：三指捏合抓红包；握拳凝聚）
// ---------------------------
let hands=null, handEnabled=false;
let lastLandmarks=null, lastLandmarksTs=0;

function dist2(a,b){
  const dx=a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0);
  return Math.sqrt(dx*dx+dy*dy+dz*dz);
}
function computeGesture(landmarks){
  const wrist=landmarks[0];
  const handSize=Math.max(1e-6, dist2(wrist, landmarks[9]));

  function extended(tip,pip){
    const dt=dist2(landmarks[tip], wrist);
    const dp=dist2(landmarks[pip], wrist);
    return dt > dp*1.12;
  }

  const thumbExt = extended(4,2);
  const indexExt = extended(8,6);
  const middleExt= extended(12,10);
  const ringExt  = extended(16,14);
  const pinkyExt = extended(20,18);

  const extCount = [thumbExt,indexExt,middleExt,ringExt,pinkyExt].filter(Boolean).length;
  const openHand = (extCount >= 4);
  const closeHand = (extCount <= 1);

  // 三指捏合：拇指+食指+中指彼此都近
  const dTI = dist2(landmarks[4], landmarks[8]) / handSize;
  const dTM = dist2(landmarks[4], landmarks[12]) / handSize;
  const dIM = dist2(landmarks[8], landmarks[12]) / handSize;
  const pinch3 = (dTI < 0.33 && dTM < 0.35 && dIM < 0.34);

  return { openHand, closeHand, pinch3 };
}

let prevOpen=false, prevClose=false, prevPinch=false;
let pinchCooldown=0;

function handleGesture(g, dt){
  const openEdge = g.openHand && !prevOpen;
  const closeEdge = g.closeHand && !prevClose;
  const pinchEdge = g.pinch3 && !prevPinch;

  prevOpen = g.openHand; prevClose = g.closeHand; prevPinch = g.pinch3;

  if(closeEdge) setMode(Mode.MERGE);
  if(openEdge)  setMode(Mode.SCATTER);

  pinchCooldown = Math.max(0, pinchCooldown - dt);
  if(pinchEdge && pinchCooldown<=0){
    triggerRedPacketFlow();
    pinchCooldown = 0.60;
  }
}

async function startHands(){
  hands = new window.Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}` });
  hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });
  hands.onResults((results)=>{
    const lm = results.multiHandLandmarks?.[0] || null;
    if(lm){ lastLandmarks=lm; lastLandmarksTs=performance.now(); }
  });

  const stream = await navigator.mediaDevices.getUserMedia({ audio:false, video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} } });
  videoEl.srcObject=stream;
  await videoEl.play();

  handEnabled=true;
  led.classList.add("on");
  statusText.textContent="手势已启用：握拳凝聚 / 张开散开 / 三指捏合抓红包";

  let busy=false, lastSent=0;
  async function pump(){
    if(!handEnabled) return;
    const now=performance.now();
    if(!busy && (now-lastSent)>33){
      busy=true; lastSent=now;
      try{ await hands.send({ image: videoEl }); }catch(e){}
      busy=false;
    }
    requestAnimationFrame(pump);
  }
  pump();
}

btnStart.addEventListener("click", async ()=>{
  try{
    btnStart.disabled=true;
    btnStart.textContent="启用中…";

    // ✅ 预热 webm：显著减少“偶尔能看到但大多数闪/卡”的情况
    await warmupVideo(horseRunVideo);

    await startHands();

    btnStart.textContent="手势识别已开启";
  }catch(e){
    statusText.textContent="启用失败：请允许摄像头权限，并确保 HTTPS";
    btnStart.disabled=false;
    btnStart.textContent="启用手势识别";
  }
});

btnReset.addEventListener("click", ()=>{
  hideFocusOverlay();
  setMode(Mode.MERGE);
  statusText.textContent="已重置：凝聚态";
});

// ---------------------------
// 相机与渲染循环
// ---------------------------
let time=0;
let lastTime=performance.now();
let yaw=0.0, pitch=0.14, radius=10.4;
let yawT=yaw, pitchT=pitch;

function applyCamera(dt){
  if(mode===Mode.MERGE){
    yawT += dt*0.12;
    pitchT = damp(pitchT, 0.14, 2.8, dt);
  }else{
    pitchT = clamp(pitchT, -0.22, 0.62);
  }
  yaw = damp(yaw, yawT, 6.0, dt);
  pitch = damp(pitch, pitchT, 6.0, dt);

  const r=radius;
  const cx = Math.sin(yaw)*Math.cos(pitch)*r;
  const cy = 2.25 + Math.sin(pitch)*r*0.33;
  const cz = Math.cos(yaw)*Math.cos(pitch)*r;
  camera.position.set(cx,cy,cz);
  camera.lookAt(0,2.25,0);

  goldPoint.position.set(Math.sin(yaw*0.7)*2.0, 5.0 + Math.sin(time*0.7)*0.12, 3.0 + Math.cos(yaw*0.7)*1.2);
}

function animate(){
  const now=performance.now();
  const dt=clamp((now-lastTime)/1000, 0, 0.035);
  lastTime=now;
  time += dt;

  if(handEnabled && lastLandmarks && (now-lastLandmarksTs)<180){
    handleGesture(computeGesture(lastLandmarks), dt);
  }

  mix = damp(mix, targetMix, 2.4, dt);
  targetFocus = (mode===Mode.FOCUS) ? 1 : 0;
  focus = damp(focus, targetFocus, 4.0, dt);

  // ✅ 散开态显示马：必须 ready 才亮相
  if(mode===Mode.SCATTER){
    if(horseReady || horseRunVideo.readyState>=2){
      horseGroup.visible = true;
    }
    updateHorseMotion(time);
  }

  updateHorseBillboard();

  // 散开态银河渐显
  const scatter01 = clamp((mix - 0.15) / 0.85, 0, 1);
  galaxy.update(time, dt, scatter01);

  // ✅ 烟花在散开态自动减弱，给视频让路
  const fwOpacity = lerp(1.0, 0.30, scatter01);
  fireworks.update(dt, fwOpacity);

  // Bloom 参数也更克制，减少“闪一下”的观感
  bloomPass.strength = damp(bloomPass.strength, 0.92, 3.0, dt);
  bloomPass.radius   = damp(bloomPass.radius,   0.62, 3.0, dt);
  bloomPass.threshold= damp(bloomPass.threshold,0.18, 3.0, dt);
  bloomMixPass.material.uniforms.uBloomIntensity.value = 0.92;

  applyCamera(dt);

  // ✅ 关键：不要再切换 camera layers（我们让需要 bloom 的物体同时属于 base+bloom）
  // 这样 base 画面始终稳定，bloom 只是叠加，不会忽隐忽现
  bloomComposer.render();
  finalComposer.render();

  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

function onResize(){
  const w=window.innerWidth, h=window.innerHeight;
  camera.aspect=w/h; camera.updateProjectionMatrix();
  renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio || 1));
  renderer.setSize(w,h,false);

  bloomComposer.setPixelRatio(Math.min(renderer.getPixelRatio(), renderer.getPixelRatio()*BLOOM_SCALE));
  bloomComposer.setSize(w,h);

  finalComposer.setPixelRatio(renderer.getPixelRatio());
  finalComposer.setSize(w,h);

  bloomPass.setSize?.(w,h);
}
window.addEventListener("resize", onResize);

// 初始：凝聚
setMode(Mode.MERGE);

// focus video
horseVideo.muted=true; horseVideo.loop=true; horseVideo.playsInline=true;
</script>
</body>
</html>
