<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>马年·手势拜年成语粒子 · Three.js + MediaPipe Hands</title>

  <!-- ES Module Shims (Import Maps for broader browser support) -->
  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/build/three.module.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/EffectComposer.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/RenderPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/UnrealBloomPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/OutputPass.js">
  <link rel="modulepreload" href="https://unpkg.com/three@0.182.0/examples/jsm/postprocessing/ShaderPass.js">

  <script type="importmap-shim">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --gold:#d4af37;
      --gold2:#ffdf8a;
      --red:#b11226;
      --red2:#ff2b4a;
      --ink:#050607;
      --panel: rgba(10,10,12,.62);
      --panel2: rgba(0,0,0,.42);
      --line: rgba(212,175,55,.35);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.68);
    }

    html,body{
      height:100%;
      margin:0;
      background:
        radial-gradient(120% 120% at 50% 28%, rgba(177,18,38,.22) 0%, rgba(0,0,0,0) 52%),
        radial-gradient(120% 120% at 50% 35%, rgba(212,175,55,.12) 0%, rgba(0,0,0,0) 58%),
        radial-gradient(120% 120% at 50% 30%, #0b0b0f 0%, #06070a 60%, #040405 100%);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, "PingFang SC","Hiragino Sans GB","Microsoft YaHei", Segoe UI, Roboto, Helvetica, Arial;
      overflow:hidden;
    }

    #app{ position:fixed; inset:0; }
    canvas#gl{ position:absolute; inset:0; width:100%; height:100%; display:block; touch-action:none; }

    /* Cinematic overlays */
    .cinema-vignette{
      position:absolute; inset:0;
      pointer-events:none;
      background:
        radial-gradient(120% 120% at 50% 42%, rgba(0,0,0,0) 40%, rgba(0,0,0,.58) 100%),
        radial-gradient(80% 60% at 50% 0%, rgba(212,175,55,.12) 0%, rgba(0,0,0,0) 55%),
        linear-gradient(180deg, rgba(177,18,38,.10) 0%, rgba(0,0,0,0) 40%);
      mix-blend-mode:screen;
      opacity:.95;
    }
    .film-grain{
      position:absolute; inset:-20%;
      pointer-events:none;
      background-image:
        repeating-linear-gradient(0deg, rgba(255,255,255,.025) 0 1px, rgba(0,0,0,0) 1px 3px),
        repeating-linear-gradient(90deg, rgba(255,255,255,.018) 0 1px, rgba(0,0,0,0) 1px 4px);
      opacity:.22;
      transform:rotate(2deg);
      animation: grain 7s linear infinite;
      mix-blend-mode:overlay;
      filter: blur(.2px);
    }
    @keyframes grain{
      0%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
      50%{ transform:translate3d(2%, 1%, 0) rotate(2deg); }
      100%{ transform:translate3d(-2%, -2%, 0) rotate(2deg); }
    }

    .hud{
      position:absolute;
      left:12px; right:12px; top:12px;
      display:flex;
      gap:10px;
      align-items:flex-start;
      pointer-events:none;
    }

    .panel{
      pointer-events:auto;
      flex:1 1 auto;
      max-width:980px;
      padding:12px 12px 10px;
      border:1px solid var(--line);
      border-radius:16px;
      background:linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);
      box-shadow: 0 18px 55px rgba(0,0,0,.52);
      backdrop-filter: blur(10px);
      position:relative;
      overflow:hidden;
    }
    .panel:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(60% 120% at 20% 0%, rgba(212,175,55,.18), rgba(0,0,0,0) 60%),
        radial-gradient(60% 120% at 80% 0%, rgba(177,18,38,.14), rgba(0,0,0,0) 60%);
      pointer-events:none;
    }

    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; position:relative; }
    .brand{ display:flex; gap:10px; align-items:center; min-width:320px; }
    .badge{
      width:12px; height:12px; border-radius:999px;
      background:var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.18), 0 0 18px rgba(212,175,55,.55);
    }
    .title{ font-weight:800; letter-spacing:.4px; font-size:14px; line-height:1.2; }
    .subtitle{ font-size:12px; color:var(--muted); margin-top:2px; }

    .controls{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-left:auto; }
    button{
      pointer-events:auto;
      appearance:none;
      border:1px solid rgba(212,175,55,.40);
      color:var(--text);
      background:linear-gradient(180deg, rgba(177,18,38,.25), rgba(0,0,0,.22));
      border-radius:12px;
      padding:10px 12px;
      font-size:12px;
      font-weight:800;
      letter-spacing:.2px;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
      cursor:pointer;
      user-select:none;
      position:relative;
    }
    button:active{ transform: translateY(1px); }
    button.secondary{
      border-color: rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.18));
      color: rgba(255,255,255,.88);
    }

    .status{
      margin-left:auto;
      font-size:12px;
      color:rgba(255,255,255,.74);
      display:flex; align-items:center; gap:8px;
    }
    .led{
      width:8px; height:8px; border-radius:999px;
      background: rgba(255,255,255,.18);
      box-shadow:0 0 0 2px rgba(255,255,255,.06);
    }
    .led.on{
      background: var(--gold);
      box-shadow: 0 0 0 2px rgba(212,175,55,.16), 0 0 16px rgba(212,175,55,.62);
    }

    .tips{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(212,175,55,.22);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      font-size:12px;
      color:rgba(255,255,255,.80);
      position:relative;
    }
    .chip{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      border-radius:999px;
      padding:6px 10px;
      display:inline-flex;
      gap:8px;
      align-items:center;
    }
    .chip b{ color:rgba(255,255,255,.94); font-weight:900; }

    /* Focus overlay: red-envelope open + video */
    .focusOverlay{
      position:absolute; inset:0;
      display:flex;
      align-items:flex-end;
      justify-content:center;
      padding:16px 12px 22px;
      pointer-events:none;
      opacity:0;
      transform: translate3d(0, 12px, 0);
      transition: opacity .25s ease, transform .25s ease;
    }
    .focusOverlay.show{
      opacity:1;
      transform: translate3d(0,0,0);
    }

    .envelopeStage{
      pointer-events:auto;
      width:min(860px, calc(100vw - 24px));
      border-radius:18px;
      border:1px solid rgba(212,175,55,.46);
      background: linear-gradient(180deg, rgba(0,0,0,.42), rgba(8,8,10,.62));
      box-shadow: 0 24px 80px rgba(0,0,0,.62);
      backdrop-filter: blur(12px);
      padding:14px 14px 12px;
      position:relative;
      overflow:hidden;
    }
    .envelopeStage:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(70% 120% at 20% 0%, rgba(212,175,55,.20), rgba(0,0,0,0) 60%),
        radial-gradient(70% 120% at 80% 0%, rgba(177,18,38,.18), rgba(0,0,0,0) 60%);
      pointer-events:none;
    }

    .focusHeader{
      display:flex; align-items:center; justify-content:space-between;
      gap:10px; flex-wrap:wrap;
      position:relative;
    }
    .focusHeader h3{
      margin:0;
      font-size:14px;
      letter-spacing:.5px;
      font-weight:900;
    }
    .focusHeader .small{
      font-size:12px; color: rgba(255,255,255,.70);
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
    }
    .kbd{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      border-radius:10px;
      padding:6px 10px;
      white-space:nowrap;
    }

    .envelopeCard{
      margin-top:12px;
      position:relative;
      height:min(52vh, 420px);
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
      background:
        radial-gradient(120% 120% at 50% 20%, rgba(255,223,138,.18), rgba(0,0,0,0) 55%),
        linear-gradient(180deg, rgba(177,18,38,.55), rgba(98,10,18,.58));
      box-shadow: inset 0 0 0 1px rgba(212,175,55,.18);
    }

    .envGlow{
      position:absolute; inset:-10%;
      background:
        radial-gradient(40% 40% at 20% 20%, rgba(255,223,138,.42), rgba(0,0,0,0) 60%),
        radial-gradient(40% 40% at 80% 60%, rgba(212,175,55,.22), rgba(0,0,0,0) 65%),
        radial-gradient(60% 60% at 50% 110%, rgba(0,0,0,.55), rgba(0,0,0,0) 55%);
      mix-blend-mode:screen;
      opacity:.9;
      pointer-events:none;
      filter: blur(1px);
    }

    .envSeal{
      position:absolute;
      left:50%; top:56%;
      transform: translate(-50%,-50%);
      width:92px; height:92px;
      border-radius:999px;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,223,138,.95), rgba(212,175,55,.65) 55%, rgba(0,0,0,0) 70%),
        radial-gradient(circle at 50% 50%, rgba(177,18,38,.70), rgba(0,0,0,0) 70%);
      box-shadow:
        0 18px 50px rgba(0,0,0,.45),
        0 0 0 2px rgba(212,175,55,.22),
        0 0 22px rgba(212,175,55,.35);
      display:flex; align-items:center; justify-content:center;
      color: rgba(255,255,255,.95);
      font-weight:1000;
      letter-spacing:.8px;
      user-select:none;
    }

    /* flap */
    .envFlap{
      position:absolute;
      left:0; right:0; top:0;
      height:55%;
      background:
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,0)),
        linear-gradient(180deg, rgba(177,18,38,.70), rgba(110,8,18,.70));
      clip-path: polygon(0 0, 100% 0, 50% 100%);
      transform-origin: 50% 0%;
      transform: rotateX(0deg);
      transition: transform .85s cubic-bezier(.2,.9,.2,1), filter .85s ease;
      filter: drop-shadow(0 10px 18px rgba(0,0,0,.35));
      border-bottom:1px solid rgba(212,175,55,.28);
    }

    .envOpen .envFlap{
      transform: rotateX(135deg);
      filter: drop-shadow(0 6px 12px rgba(0,0,0,.25));
    }

    .revealBody{
      position:absolute; inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      opacity:0;
      transform: translate3d(0,10px,0);
      transition: opacity .35s ease, transform .35s ease;
      pointer-events:none;
    }
    .envOpen .revealBody{
      opacity:1;
      transform: translate3d(0,0,0);
      pointer-events:auto;
    }

    .revealGrid{
      width:100%;
      max-width:760px;
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:14px;
      align-items:stretch;
    }

    .videoWrap{
      border-radius:14px;
      border:1px solid rgba(212,175,55,.40);
      background: rgba(0,0,0,.26);
      overflow:hidden;
      box-shadow: 0 18px 55px rgba(0,0,0,.42);
      position:relative;
    }
    .videoWrap:before{
      content:"";
      position:absolute; inset:-2px;
      background:
        radial-gradient(50% 100% at 20% 0%, rgba(212,175,55,.18), rgba(0,0,0,0) 55%),
        radial-gradient(50% 100% at 80% 0%, rgba(255,43,74,.12), rgba(0,0,0,0) 55%);
      pointer-events:none;
      mix-blend-mode:screen;
      opacity:.85;
    }

    #horseVideo{
      width:100%;
      height:100%;
      display:block;
      object-fit:cover;
      background:#000;
    }

    .messageCard{
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.22);
      padding:12px 12px 10px;
      box-shadow: inset 0 0 0 1px rgba(212,175,55,.12);
    }
    .messageCard h4{
      margin:0 0 8px;
      font-size:14px;
      letter-spacing:.6px;
      font-weight:1000;
      color: rgba(255,255,255,.96);
    }
    .messageCard p{
      margin:0;
      font-size:13px;
      line-height:1.65;
      color: rgba(255,255,255,.88);
      white-space:pre-wrap;
    }
    .messageCard .hint{
      margin-top:10px;
      font-size:12px;
      color: rgba(255,255,255,.70);
      display:flex; gap:10px; flex-wrap:wrap;
    }

    /* Hidden camera element (MediaPipe requires it) */
    video#cam{
      position:absolute;
      right:12px; bottom:12px;
      width:120px; height:160px;
      opacity:0;
      pointer-events:none;
      transform: translateZ(0);
    }

    @media (max-width:720px){
      .brand{ min-width: 250px; }
      .revealGrid{ grid-template-columns: 1fr; }
      .envelopeCard{ height:min(56vh, 440px); }
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="gl"></canvas>
    <div class="cinema-vignette"></div>
    <div class="film-grain"></div>

    <div class="hud">
      <div class="panel">
        <div class="row">
          <div class="brand">
            <span class="badge"></span>
            <div>
              <div class="title">马年·手势拜年成语粒子</div>
              <div class="subtitle">Three.js / WebGL · MediaPipe Hands · 金红辉光 · 红包开封·视频祝福</div>
            </div>
          </div>

          <div class="controls">
            <button id="btnStart">启用手势识别</button>
            <button id="btnReset" class="secondary">重置</button>
            <button id="btnHelp" class="secondary">玩法提示</button>
          </div>

          <div class="status">
            <span id="led" class="led"></span>
            <span id="statusText">默认：合拢态（成语聚合）</span>
          </div>
        </div>

        <div class="tips" id="tips" style="display:none;">
          <span class="chip"><b>握拳</b> → 回到合拢态（随机成语）</span>
          <span class="chip"><b>张开五指</b> → 散开态</span>
          <span class="chip"><b>手掌移动/旋转</b> → 在散开态旋转画面</span>
          <span class="chip"><b>三指抓（拇指+食指+中指）</b> → 抓到红包，开封后播放视频+成语</span>
          <span class="chip"><b>双击画面</b> → 触发“抓红包”（无手势兜底）</span>
        </div>
      </div>
    </div>

    <div id="focusOverlay" class="focusOverlay">
      <div class="envelopeStage">
        <div class="focusHeader">
          <h3 id="focusTitle">抓到一个红包</h3>
          <div class="small">
            <span class="kbd">再抓一次：换一个红包</span>
            <span class="kbd">握拳：回到合拢态</span>
          </div>
        </div>

        <div id="envelopeCard" class="envelopeCard">
          <div class="envGlow"></div>
          <div class="envFlap"></div>
          <div class="envSeal" id="envSeal">开</div>

          <div class="revealBody">
            <div class="revealGrid">
              <div class="videoWrap">
                <video id="horseVideo" playsinline muted loop></video>
              </div>
              <div class="messageCard">
                <h4 id="idiomText">马到成功</h4>
                <p id="idiomDesc">祝你马年顺顺利利，事事成！</p>
                <div class="hint">
                  <span class="kbd">提示：允许相机权限后手势更流畅</span>
                  <span class="kbd">提示：视频文件放在 assets/videos/</span>
                </div>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>

    <video id="cam" playsinline></video>
  </div>

  <script type="module-shim">
    import * as THREE from "three";
    import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
    import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
    import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
    import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
    import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

    // ---------------------------
    // Config
    // ---------------------------
    const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const DPR_CAP = IS_MOBILE ? 1.25 : 2.0;

    const COLORS = {
      gold: new THREE.Color("#d4af37"),
      gold2: new THREE.Color("#ffdf8a"),
      red: new THREE.Color("#b11226"),
      red2: new THREE.Color("#ff2b4a"),
      ink: new THREE.Color("#040405")
    };

    const IDIOMS = [
      { text: "马到成功", desc: "形容事情顺利，一开始就取得成功。" },
      { text: "龙马精神", desc: "形容精神健旺，充满活力。" },
      { text: "一马当先", desc: "形容领先，带头前进。" },
      { text: "万马奔腾", desc: "形容声势浩大，气势磅礴。" },
      { text: "马上发财", desc: "谐音吉祥语，寓意立即发财。" },
      { text: "马上如意", desc: "谐音吉祥语，寓意立即顺心如意。" },

      { text: "策马扬鞭", desc: "比喻奋发向前，勇往直前。" },
      { text: "快马加鞭", desc: "比喻加快前进速度，乘势而上。" },
      { text: "一马平川", desc: "比喻前途平坦，没有阻碍。" },
      { text: "天马行空", desc: "比喻才华横溢，不受拘束。" },
      { text: "马到功成", desc: "事业顺利，功成名就。" },
      { text: "马跃钱程", desc: "谐音“前程”，寓意财运亨通。" },

      { text: "人强马壮", desc: "形容身体强壮，精力充沛。" },
      { text: "金戈铁马", desc: "形容英勇善战，精神振奋。" },
      { text: "骏马奔腾", desc: "形容生机勃勃，活力四射。" },
      { text: "马蹄生风", desc: "形容行动迅速，充满活力。" },

      { text: "马年大吉", desc: "马年专用祝福语，万事皆顺。" },
      { text: "马年行运", desc: "寓意好运连连，事事顺遂。" },
      { text: "马年祥瑞", desc: "寓意马年吉祥如意，福泽满满。" },
      { text: "金马迎春", desc: "寓意财富与新春同在，喜气盈门。" },
      { text: "宝马香车", desc: "寓意生活富足美满，出行顺心。" },
      { text: "马首是瞻", desc: "比喻追随正确方向，目标明确。" },

      { text: "马到财来", desc: "谐音“财到”，寓意财运亨通。" },
      { text: "马到福来", desc: "谐音“福到”，寓意福气到来。" },
      { text: "马到运来", desc: "谐音“运到”，寓意好运连连。" },

      { text: "马上有钱", desc: "现代流行语，寓意立即富有。" },
      { text: "马上有房", desc: "现代流行语，寓意立即置业。" },
      { text: "马上有爱", desc: "现代祝福语，寓意爱情美满。" },
      { text: "马力全开", desc: "现代用语，寓意全力以赴，势如破竹。" }
    ];

    // 你把马的视频放在这些路径（可自行增加）
    const HORSE_VIDEOS = [
      "assets/videos/horse1.mp4",
      "assets/videos/horse2.mp4",
      "assets/videos/horse3.mp4"
    ];

    // ---------------------------
    // DOM
    // ---------------------------
    const canvas = document.getElementById("gl");
    const statusText = document.getElementById("statusText");
    const led = document.getElementById("led");
    const btnStart = document.getElementById("btnStart");
    const btnReset = document.getElementById("btnReset");
    const btnHelp  = document.getElementById("btnHelp");
    const tipsEl   = document.getElementById("tips");

    const focusOverlay = document.getElementById("focusOverlay");
    const focusTitleEl = document.getElementById("focusTitle");
    const envelopeCard = document.getElementById("envelopeCard");
    const envSeal = document.getElementById("envSeal");
    const idiomTextEl = document.getElementById("idiomText");
    const idiomDescEl = document.getElementById("idiomDesc");
    const horseVideo = document.getElementById("horseVideo");

    const videoCamEl = document.getElementById("cam");

    // ---------------------------
    // Utils
    // ---------------------------
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    const lerp  = (a,b,t)=>a+(b-a)*t;
    const damp  = (current, target, lambda, dt)=>{
      const t = 1 - Math.exp(-lambda * dt);
      return current + (target - current) * t;
    };
    const randRange = (a,b)=>a+Math.random()*(b-a);

    function choose(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    function safePlayVideo(el){
      if(!el) return;
      const p = el.play();
      if(p && typeof p.catch==="function") p.catch(()=>{});
    }

    function setStatus(txt){ statusText.textContent = txt; }

    // ---------------------------
    // Text sampling: build target points for idiom
    // ---------------------------
    function sampleTextPoints(text, {
      fontSize = 220,
      weight = 900,
      step = IS_MOBILE ? 3 : 2,        // 小一点的点 + 更清晰边缘
      padding = 70,
      threshold = 18,
      worldWidth = 6.6
    } = {}) {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      const c = document.createElement("canvas");
      const ctx = c.getContext("2d", { willReadFrequently: true });

      const font = `${weight} ${fontSize}px "PingFang SC","Hiragino Sans GB","Microsoft YaHei",ui-sans-serif,system-ui`;
      ctx.font = font;
      const metrics = ctx.measureText(text);

      const cssW = Math.ceil(metrics.width + padding*2);
      const cssH = Math.ceil(fontSize*1.2 + padding*2);

      c.width  = Math.ceil(cssW * dpr);
      c.height = Math.ceil(cssH * dpr);

      ctx.setTransform(dpr,0,0,dpr,0,0);
      ctx.clearRect(0,0,cssW,cssH);

      // 为了边缘清晰：先描边再填充
      ctx.font = font;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.lineWidth = 8;
      ctx.strokeStyle = "rgba(255,255,255,1.0)";
      ctx.fillStyle = "rgba(255,255,255,1.0)";
      ctx.strokeText(text, cssW/2, cssH/2);
      ctx.fillText(text, cssW/2, cssH/2);

      const img = ctx.getImageData(0,0,c.width,c.height).data;
      const pts = [];
      const stepPx = Math.max(1, Math.round(step * dpr));

      for(let y=0; y<c.height; y+=stepPx){
        for(let x=0; x<c.width; x+=stepPx){
          const a = img[(y*c.width + x)*4 + 3];
          if(a > threshold) pts.push([x/dpr, y/dpr]);
        }
      }

      // convert to world positions
      const scale = worldWidth / cssW;
      const out = [];
      for(const [xCss,yCss] of pts){
        const x = (xCss - cssW/2) * scale;
        const y = (cssH/2 - yCss) * scale;
        out.push(new THREE.Vector3(x,y,0));
      }
      return out;
    }

    function buildTargetsFromSamples(samples, count, jitter=0.015){
      // 保证目标点数量 >= 粒子数：不足就随机重复并做轻微抖动
      const out = new Float32Array(count*3);
      const n = samples.length;
      for(let i=0;i<count;i++){
        const v = samples[Math.floor(Math.random()*n)];
        out[i*3+0] = v.x + randRange(-jitter, jitter);
        out[i*3+1] = v.y + randRange(-jitter, jitter);
        out[i*3+2] = v.z + randRange(-jitter, jitter);
      }
      return out;
    }

    // ---------------------------
    // Glyph texture: tiny “马”
    // ---------------------------
    function makeMaGlyphTexture(size=128){
      const c = document.createElement("canvas");
      c.width = size; c.height = size;
      const ctx = c.getContext("2d");

      ctx.clearRect(0,0,size,size);

      // subtle glow background
      const g = ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size*0.48);
      g.addColorStop(0, "rgba(255,223,138,0.22)");
      g.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,size,size);

      // draw “马” with stroke to be crisp
      ctx.save();
      ctx.translate(size/2,size/2);

      const fontSize = Math.round(size*0.78);
      ctx.font = `900 ${fontSize}px "PingFang SC","Hiragino Sans GB","Microsoft YaHei",ui-sans-serif,system-ui`;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";

      ctx.lineWidth = Math.max(10, Math.round(size*0.09));
      ctx.strokeStyle = "rgba(255,255,255,0.96)";
      ctx.strokeText("马", 0, 4);

      ctx.fillStyle = "rgba(255,255,255,0.98)";
      ctx.fillText("马", 0, 4);

      ctx.restore();

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = false;
      return tex;
    }

    function makeEnvelopeTexture(w=256,h=256){
      const c = document.createElement("canvas");
      c.width=w; c.height=h;
      const ctx=c.getContext("2d");

      // base red
      const g = ctx.createLinearGradient(0,0,0,h);
      g.addColorStop(0,"#ff2b4a");
      g.addColorStop(1,"#9e0f22");
      ctx.fillStyle=g;
      ctx.fillRect(0,0,w,h);

      // gold border
      ctx.strokeStyle="rgba(212,175,55,0.90)";
      ctx.lineWidth=Math.max(10,Math.round(w*0.05));
      ctx.strokeRect(Math.round(w*0.08),Math.round(h*0.08),Math.round(w*0.84),Math.round(h*0.84));

      // inner glow
      const g2=ctx.createRadialGradient(w*0.35,h*0.25,0,w*0.35,h*0.25,w*0.70);
      g2.addColorStop(0,"rgba(255,223,138,0.55)");
      g2.addColorStop(1,"rgba(0,0,0,0)");
      ctx.fillStyle=g2;
      ctx.fillRect(0,0,w,h);

      // “福”
      ctx.font=`900 ${Math.round(w*0.46)}px "PingFang SC","Hiragino Sans GB","Microsoft YaHei",ui-sans-serif,system-ui`;
      ctx.textAlign="center";
      ctx.textBaseline="middle";
      ctx.lineWidth=Math.max(10,Math.round(w*0.05));
      ctx.strokeStyle="rgba(212,175,55,0.92)";
      ctx.strokeText("福", w/2, h*0.56);
      ctx.fillStyle="rgba(255,255,255,0.94)";
      ctx.fillText("福", w/2, h*0.56);

      const tex = new THREE.CanvasTexture(c);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearFilter;
      tex.magFilter = THREE.LinearFilter;
      tex.generateMipmaps = false;
      return tex;
    }

    // ---------------------------
    // Three.js Setup
    // ---------------------------
    const renderer = new THREE.WebGLRenderer({
      canvas,
      antialias: true,
      alpha: false,
      powerPreference: "high-performance"
    });
    renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio || 1));
    renderer.setSize(window.innerWidth, window.innerHeight, false);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.08;

    const scene = new THREE.Scene();
    scene.background = COLORS.ink;

    const fog = new THREE.FogExp2(0x06060a, 0.070);
    scene.fog = fog;

    const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 140);

    // Lighting: gold + red
    scene.add(new THREE.AmbientLight(0xffffff, 0.22));

    const keyLight = new THREE.DirectionalLight(0xfff2d6, 1.05);
    keyLight.position.set(6, 8, 6);
    scene.add(keyLight);

    const rimLight = new THREE.DirectionalLight(0xd4af37, 0.65);
    rimLight.position.set(-6, 4, -6);
    scene.add(rimLight);

    const goldPoint = new THREE.PointLight(0xd4af37, 1.35, 22, 2);
    goldPoint.position.set(0, 5.2, 2.6);
    scene.add(goldPoint);

    const redPoint = new THREE.PointLight(0xb11226, 0.95, 18, 2);
    redPoint.position.set(-2.6, 3.2, 2.2);
    scene.add(redPoint);

    // ---------------------------
    // Postprocessing: selective bloom
    // ---------------------------
    const BLOOM_LAYER = 1;

    const bloomComposer = new EffectComposer(renderer);
    bloomComposer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(
      new THREE.Vector2(window.innerWidth, window.innerHeight),
      1.18, 0.62, 0.16
    );
    bloomComposer.addPass(bloomPass);

    const finalComposer = new EffectComposer(renderer);
    finalComposer.addPass(new RenderPass(scene, camera));

    const bloomMixPass = new ShaderPass(
      new THREE.ShaderMaterial({
        uniforms: {
          baseTexture: { value: null },
          bloomTexture: { value: bloomComposer.renderTarget2.texture },
          uBloomIntensity: { value: 1.0 }
        },
        vertexShader: /* glsl */`
          varying vec2 vUv;
          void main(){ vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }
        `,
        fragmentShader: /* glsl */`
          uniform sampler2D baseTexture;
          uniform sampler2D bloomTexture;
          uniform float uBloomIntensity;
          varying vec2 vUv;
          void main(){
            vec4 base = texture2D(baseTexture, vUv);
            vec4 bloom = texture2D(bloomTexture, vUv);
            gl_FragColor = base + bloom * uBloomIntensity;
          }
        `
      }),
      "baseTexture"
    );
    finalComposer.addPass(bloomMixPass);
    finalComposer.addPass(new OutputPass());

    // ---------------------------
    // State machine
    // ---------------------------
    const Mode = { CLUSTER:"CLUSTER", SCATTER:"SCATTER", REVEAL:"REVEAL" };
    let mode = Mode.CLUSTER;

    let mix = 0;           // 0 cluster, 1 scatter
    let targetMix = 0;

    let reveal = 0;        // 0 not reveal, 1 reveal
    let targetReveal = 0;

    let currentIdiom = choose(IDIOMS);

    function showOverlay(){
      focusOverlay.classList.add("show");
    }
    function hideOverlay(){
      focusOverlay.classList.remove("show");
      envelopeCard.classList.remove("envOpen");
      // reset seal text
      envSeal.textContent = "开";
    }

    function setMode(next){
      if(mode === next) return;

      // transitions
      if(next === Mode.CLUSTER){
        mode = next;
        targetMix = 0;
        targetReveal = 0;
        hideOverlay();
        // 每次回到合拢态：随机成语并重建目标
        pickNewIdiom(true);
        setStatus("合拢态：成语聚合（已随机切换）");
      } else if(next === Mode.SCATTER){
        mode = next;
        targetMix = 1;
        targetReveal = 0;
        hideOverlay();
        setStatus("散开态：粒子与红包在空间漂浮");
        // 触发“惯性甩出去”
        envelopesImpulseBurst();
      } else if(next === Mode.REVEAL){
        mode = next;
        targetMix = 1;
        targetReveal = 1;
        showOverlay();
        setStatus("抓到红包：开封后播放视频与成语祝福");
        // 进入REVEAL也给一点外扩动量，营造庆祝爆散
        envelopesImpulseBurst(0.65);
        fireworks.burst(2); // 立即来一波烟花
        confetti.emit(1.0); // 红包小纸片雨
      }
    }

    // ---------------------------
    // Idiom particle system (Points with “马” glyph)
    // ---------------------------
    const idiomGroup = new THREE.Group();
    scene.add(idiomGroup);
    idiomGroup.position.set(0, 2.25, 0);

    const PARTICLE_COUNT = IS_MOBILE ? 18000 : 26000;

    function sampleScatterSphere(R=7.8){
      const u=Math.random(), v=Math.random();
      const theta=u*Math.PI*2;
      const phi=Math.acos(2*v-1);
      const rr=(0.45 + Math.pow(Math.random(),0.75)*0.55)*R;
      return new THREE.Vector3(
        rr*Math.sin(phi)*Math.cos(theta),
        rr*Math.cos(phi)*0.78 + 2.1,
        rr*Math.sin(phi)*Math.sin(theta)
      );
    }

    // geometry attributes
    const idiomGeo = new THREE.BufferGeometry();
    const aHome = new Float32Array(PARTICLE_COUNT*3);
    const aScatter = new Float32Array(PARTICLE_COUNT*3);
    const aRand = new Float32Array(PARTICLE_COUNT);

    for(let i=0;i<PARTICLE_COUNT;i++){
      const s = sampleScatterSphere(8.2);
      aScatter[i*3+0]=s.x; aScatter[i*3+1]=s.y; aScatter[i*3+2]=s.z;
      aRand[i]=Math.random();
    }

    idiomGeo.setAttribute("aHome", new THREE.BufferAttribute(aHome,3));
    idiomGeo.setAttribute("aScatter", new THREE.BufferAttribute(aScatter,3));
    idiomGeo.setAttribute("aRand", new THREE.BufferAttribute(aRand,1));
    // provide a stable position attribute
    idiomGeo.setAttribute("position", new THREE.BufferAttribute(aHome,3));
    idiomGeo.computeBoundingSphere();

    const maTex = makeMaGlyphTexture(128);

    const idiomMat = new THREE.ShaderMaterial({
      transparent: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      uniforms: {
        uTime: { value: 0 },
        uMix: { value: 0 },
        uReveal: { value: 0 },
        uGlyph: { value: maTex },
        uBaseSize: { value: IS_MOBILE ? 0.82 : 0.78 }  // 粒子更小
      },
      vertexShader: /* glsl */`
        uniform float uTime;
        uniform float uMix;
        uniform float uReveal;
        uniform float uBaseSize;

        attribute vec3 aHome;
        attribute vec3 aScatter;
        attribute float aRand;

        varying float vRand;
        varying float vTw;
        varying float vFade;

        void main(){
          vRand = aRand;
          vec3 pos = mix(aHome, aScatter, uMix);

          float t = uTime * (0.65 + aRand*1.2);

          // delicate drift
          pos.x += cos(t*1.12 + aRand*6.3) * (0.020 + aRand*0.040);
          pos.y += sin(t*0.95 + aRand*5.1) * (0.018 + aRand*0.040);
          pos.z += sin(t*0.85 + aRand*4.7) * (0.020 + aRand*0.040);

          // reveal: slight push away for depth
          pos *= (1.0 + uReveal*(0.08 + aRand*0.18));

          vec4 mv = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mv;

          float dist = max(0.001, -mv.z);

          // smaller points and less "too near" feeling
          float size = uBaseSize * (62.0 / dist);

          // twinkle
          vTw = 0.75 + 0.25*sin(uTime*2.4 + aRand*14.0);
          size *= (0.92 + 0.10*vTw);

          // clamp small
          gl_PointSize = clamp(size, 0.55, 2.2);

          // fade in reveal slightly for readability
          vFade = 1.0 - uReveal*0.08;
        }
      `,
      fragmentShader: /* glsl */`
        precision highp float;
        uniform sampler2D uGlyph;
        uniform float uReveal;

        varying float vRand;
        varying float vTw;
        varying float vFade;

        void main(){
          vec2 uv = gl_PointCoord;

          // glyph alpha
          vec4 g = texture2D(uGlyph, uv);
          float a = g.a;

          // soft edge to avoid harsh squares
          vec2 p = uv - 0.5;
          float d = length(p);
          float soft = smoothstep(0.55, 0.35, d);

          a *= soft;
          if(a < 0.04) discard;

          // festive color (no plain white): gold-red ramp
          vec3 gold = vec3(0.83, 0.69, 0.22);
          vec3 gold2= vec3(1.00, 0.88, 0.55);
          vec3 red  = vec3(0.70, 0.07, 0.15);
          vec3 red2 = vec3(1.00, 0.17, 0.30);

          float m1 = smoothstep(0.10, 0.92, vRand);
          vec3 col = mix(gold, gold2, m1);
          col = mix(col, red, smoothstep(0.72, 0.98, vRand)*0.55);
          col = mix(col, red2, smoothstep(0.86, 0.995, vRand)*0.28);

          // reveal: slightly more colorful
          col = mix(col, col * vec3(1.06, 1.02, 1.12), uReveal*0.55);

          float glow = (0.78 + 0.60*vTw);
          float alpha = a * glow * 0.55 * vFade;

          gl_FragColor = vec4(col * (1.05 + 0.65*(1.0-soft)), alpha);
        }
      `
    });

    const idiomPoints = new THREE.Points(idiomGeo, idiomMat);
    idiomGroup.add(idiomPoints);
    idiomPoints.layers.enable(BLOOM_LAYER);
    let envHomeRingR = 3.0; // 红包环绕半径（会在 rebuildIdiomTargets 里更新）
    function rebuildIdiomTargets(text){
      // sample points for idiom text
      const samples = sampleTextPoints(text, {
        fontSize: IS_MOBILE ? 200 : 240,
        step: IS_MOBILE ? 3 : 2,
        worldWidth: IS_MOBILE ? 6.4 : 7.2,
        threshold: 20,
        padding: 80
      });

      const home = buildTargetsFromSamples(samples, PARTICLE_COUNT, 0.012);
      const attr = idiomGeo.getAttribute("aHome");
      attr.array.set(home);
      attr.needsUpdate = true;

      // keep stable position attribute
      const posAttr = idiomGeo.getAttribute("position");
      posAttr.array.set(home);
      posAttr.needsUpdate = true;

      idiomGeo.computeBoundingSphere();
      idiomGeo.computeBoundingSphere();

      // 新增：红包环绕半径随成语尺寸自适应
      envHomeRingR = Math.max(2.4, Math.min(4.6, idiomGeo.boundingSphere?.radius * 1.05 || 3.0));

    }

    function pickNewIdiom(updateTargets=false){
      currentIdiom = choose(IDIOMS);
      idiomTextEl.textContent = currentIdiom.text;
      idiomDescEl.textContent = currentIdiom.desc;
      if(updateTargets) rebuildIdiomTargets(currentIdiom.text);
    }

    // initial build
    rebuildIdiomTargets(currentIdiom.text);

    // ---------------------------
    // Envelopes: InstancedMesh with inertia + spring to targets
    // ---------------------------
    const ENVELOPE_COUNT = IS_MOBILE ? 140 : 220;

    const envTex = makeEnvelopeTexture(256,256);

    const envMat = new THREE.MeshBasicMaterial({
      map: envTex,
      transparent: true,
      opacity: 0.95,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      toneMapped: false
    });

    const envGeo = new THREE.PlaneGeometry(0.18, 0.24);
    const envelopes = new THREE.InstancedMesh(envGeo, envMat, ENVELOPE_COUNT);
    envelopes.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    scene.add(envelopes);
    envelopes.layers.enable(BLOOM_LAYER);

    // physics state
    const envPos = new Array(ENVELOPE_COUNT);
    const envVel = new Array(ENVELOPE_COUNT);
    const envHomeLocal = new Array(ENVELOPE_COUNT);
    const envScatterWorld = new Array(ENVELOPE_COUNT);
    const envSeed = new Array(ENVELOPE_COUNT);
    envHomeRingR = 3.0; // 会在每次生成新成语后自适应更新

    function sampleEnvelopeHomeLocal(){
      // 围绕文字的“环”，并留一点厚度，避免全都在一个平面
      const ang = Math.random() * Math.PI * 2;
    
      // 让半径围绕 envHomeRingR 波动（形成一个环形带）
      const r = envHomeRingR * (0.82 + Math.random() * 0.42);
    
      // y 范围决定红包在字上下的环绕幅度（这里是围绕字，而不是跑到字上方）
      const y = (Math.random() - 0.5) * 1.6;
    
      // z 给一点厚度，看起来更立体地环绕
      const z = (Math.random() - 0.5) * 1.2;
    
      return new THREE.Vector3(Math.cos(ang) * r, y, z);
    }


    function sampleEnvelopeScatterWorld(){
      const R=7.4;
      const u=Math.random(), v=Math.random();
      const theta=u*Math.PI*2;
      const phi=Math.acos(2*v-1);
      const rr=(0.46 + Math.pow(Math.random(),0.70)*0.54)*R;
      return new THREE.Vector3(
        rr*Math.sin(phi)*Math.cos(theta),
        rr*Math.cos(phi)*0.78 + 2.3,
        rr*Math.sin(phi)*Math.sin(theta)
      );
    }

    for(let i=0;i<ENVELOPE_COUNT;i++){
      envHomeLocal[i] = sampleEnvelopeHomeLocal();
      envScatterWorld[i] = sampleEnvelopeScatterWorld();
      envPos[i] = new THREE.Vector3().copy(envScatterWorld[i]); // start around scatter-ish
      envVel[i] = new THREE.Vector3(0,0,0);
      envSeed[i] = Math.random()*1000;
    }

    const _obj = new THREE.Object3D();
    const _tmp = new THREE.Vector3();
    const _homeWorld = new THREE.Vector3();

    function envelopesImpulseBurst(strength=1.0){
      // “惯性甩出去”：给速度一个外扩冲量 + 随机
      // 强度随设备调整，避免移动端过炸
      const k = (IS_MOBILE ? 1.10 : 1.35) * strength;

      // 以成语中心为基准
      const c = idiomGroup.position;

      for(let i=0;i<ENVELOPE_COUNT;i++){
        const p = envPos[i];
        const v = envVel[i];

        _tmp.subVectors(p, c);
        const dist = Math.max(0.001, _tmp.length());
        _tmp.multiplyScalar(1.0/dist);

        // outward impulse with a little upward lift
        v.addScaledVector(_tmp, k * (1.6 + Math.random()*1.2));
        v.y += k * (0.65 + Math.random()*0.75);

        // tiny lateral randomness
        v.x += randRange(-0.65,0.65) * k;
        v.z += randRange(-0.65,0.65) * k;
      }
    }

    function updateEnvelopes(time, dt){
      // targets depend on mix: 0 home around idiom, 1 scatter world
      const q = idiomGroup.quaternion;
      const c = idiomGroup.position;

      // spring params
      const spring = (mode === Mode.REVEAL) ? 10.0 : 8.0;
      const damping = (mode === Mode.REVEAL) ? 0.88 : 0.86;

      // opacity follows mix (more visible in scatter/reveal)
      envMat.opacity = lerp(0.28, 0.95, mix) * (0.94 + 0.06*Math.sin(time*2.0));

      for(let i=0;i<ENVELOPE_COUNT;i++){
        // home target in world: local -> rotate with idiom group -> translate -> lift to idiom height
        // home target：直接围绕 idiomGroup 的中心（idiomGroup.position 本来就在字的高度）
        _homeWorld.copy(envHomeLocal[i]).applyQuaternion(q).add(c);


        const scatter = envScatterWorld[i];

        const tx = lerp(_homeWorld.x, scatter.x, mix);
        const ty = lerp(_homeWorld.y, scatter.y, mix);
        const tz = lerp(_homeWorld.z, scatter.z, mix);

        // idle drift
        const t = time*(0.60 + (envSeed[i]%1.0)*1.2);
        const driftX = Math.sin(t + envSeed[i])*0.12;
        const driftY = Math.cos(t*0.9 + envSeed[i])*0.10;
        const driftZ = Math.sin(t*0.8 + envSeed[i])*0.12;

        const target = _tmp.set(tx+driftX, ty+driftY, tz+driftZ);

        // physics: velocity + spring to target (gives inertia overshoot)
        const p = envPos[i];
        const v = envVel[i];

        // a = (target - p) * spring
        v.x += (target.x - p.x) * spring * dt;
        v.y += (target.y - p.y) * spring * dt;
        v.z += (target.z - p.z) * spring * dt;

        // damping
        v.multiplyScalar(Math.pow(damping, dt*60.0));

        // integrate
        p.addScaledVector(v, dt);

        // orient toward camera
        _obj.position.copy(p);
        _obj.lookAt(camera.position);

        // subtle wobble
        _obj.rotateZ(Math.sin(t*0.7)*0.10);
        _obj.rotateX(Math.cos(t*0.5)*0.06);

        // reveal: a little larger
        const sc = lerp(0.90, 1.10, reveal) * (0.88 + (i%7)*0.02);
        _obj.scale.set(sc, sc, 1);
        _obj.updateMatrix();
        envelopes.setMatrixAt(i, _obj.matrix);
      }

      envelopes.instanceMatrix.needsUpdate = true;
    }

    // ---------------------------
    // Fireworks (multicolor) + Red-packet confetti
    // ---------------------------
    class FireworksSystem {
      constructor(maxParticles=IS_MOBILE?2200:3600){
        this.max = maxParticles;
        this.count = 0;

        this.pos = new Float32Array(this.max*3);
        this.vel = new Float32Array(this.max*3);
        this.col = new Float32Array(this.max*3);
        this.life= new Float32Array(this.max);
        this.seed= new Float32Array(this.max);

        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(this.pos,3));
        geo.setAttribute("aVel", new THREE.BufferAttribute(this.vel,3));
        geo.setAttribute("aCol", new THREE.BufferAttribute(this.col,3));
        geo.setAttribute("aLife", new THREE.BufferAttribute(this.life,1));
        geo.setAttribute("aSeed", new THREE.BufferAttribute(this.seed,1));

        this.mat = new THREE.ShaderMaterial({
          transparent:true,
          depthWrite:false,
          blending:THREE.AdditiveBlending,
          uniforms:{
            uTime:{value:0},
            uSize:{value: IS_MOBILE? 1.15: 1.25}
          },
          vertexShader: /* glsl */`
            uniform float uTime;
            uniform float uSize;
            attribute vec3 aVel;
            attribute vec3 aCol;
            attribute float aLife;
            attribute float aSeed;
            varying vec3 vCol;
            varying float vLife;
            varying float vTw;
            void main(){
              vCol = aCol;
              vLife = aLife;

              vec4 mv = modelViewMatrix * vec4(position,1.0);
              gl_Position = projectionMatrix * mv;

              float dist = max(0.001, -mv.z);
              float tw = 0.75 + 0.25*sin(uTime*6.0 + aSeed*12.0);
              vTw = tw;

              gl_PointSize = clamp(uSize * tw * (70.0 / dist) * (0.40 + 0.60*aLife), 0.7, 6.0);
            }
          `,
          fragmentShader: /* glsl */`
            precision highp float;
            varying vec3 vCol;
            varying float vLife;
            varying float vTw;
            void main(){
              vec2 uv = gl_PointCoord - 0.5;
              float d = length(uv);
              float core = smoothstep(0.26, 0.0, d);
              float halo = smoothstep(0.62, 0.18, d) * 0.55;
              float a = (core + halo) * vLife * (0.75 + 0.55*vTw);
              if(a < 0.01) discard;
              gl_FragColor = vec4(vCol * (1.1 + 0.9*halo), a);
            }
          `
        });

        this.points = new THREE.Points(geo, this.mat);
        this.points.renderOrder = 10;
        this.points.layers.enable(BLOOM_LAYER);
        scene.add(this.points);

        this.palette = [
          new THREE.Color("#ffdf8a"),
          new THREE.Color("#d4af37"),
          new THREE.Color("#ff2b4a"),
          new THREE.Color("#9cff57"),
          new THREE.Color("#49b7ff"),
          new THREE.Color("#c56dff"),
          new THREE.Color("#ffffff")
        ];
      }

      burst(mult=1){
        // spawn 1~3 bursts
        const bursts = Math.floor(randRange(1, 3.6) * mult);
        for(let b=0;b<bursts;b++){
          const center = new THREE.Vector3(
            randRange(-2.8,2.8),
            randRange(2.3,5.8),
            randRange(-2.0,2.0)
          );
          const n = Math.floor(randRange(120, 220) * (IS_MOBILE ? 0.75 : 1.0));
          const col = choose(this.palette).clone();

          for(let i=0;i<n;i++){
            if(this.count >= this.max) break;
            const idx = this.count++;

            const u=Math.random(), v=Math.random();
            const theta=u*Math.PI*2;
            const phi=Math.acos(2*v-1);
            const sp=randRange(2.2,5.8) * (0.75 + Math.random()*0.60);

            const vx = Math.sin(phi)*Math.cos(theta)*sp;
            const vy = Math.cos(phi)*sp + randRange(0.2,1.0);
            const vz = Math.sin(phi)*Math.sin(theta)*sp;

            this.pos[idx*3+0]=center.x;
            this.pos[idx*3+1]=center.y;
            this.pos[idx*3+2]=center.z;

            this.vel[idx*3+0]=vx;
            this.vel[idx*3+1]=vy;
            this.vel[idx*3+2]=vz;

            // slight variance
            const c = col.clone().multiplyScalar(0.85 + Math.random()*0.55);
            this.col[idx*3+0]=c.r;
            this.col[idx*3+1]=c.g;
            this.col[idx*3+2]=c.b;

            this.life[idx]=1.0;
            this.seed[idx]=Math.random()*1000;
          }
        }

        // mark updates
        this.points.geometry.attributes.position.needsUpdate = true;
        this.points.geometry.attributes.aVel.needsUpdate = true;
        this.points.geometry.attributes.aCol.needsUpdate = true;
        this.points.geometry.attributes.aLife.needsUpdate = true;
        this.points.geometry.attributes.aSeed.needsUpdate = true;
      }

      update(dt, time){
        this.mat.uniforms.uTime.value = time;

        const g = -6.4; // gravity
        const drag = 0.985;

        for(let i=0;i<this.count;i++){
          let life = this.life[i];
          if(life <= 0) continue;

          // fade
          life -= dt * (0.75 + 0.35*Math.random());
          this.life[i]=life;

          const px = i*3;

          // integrate velocity
          this.vel[px+1] += g*dt;
          this.vel[px+0] *= Math.pow(drag, dt*60.0);
          this.vel[px+1] *= Math.pow(drag, dt*60.0);
          this.vel[px+2] *= Math.pow(drag, dt*60.0);

          this.pos[px+0] += this.vel[px+0]*dt;
          this.pos[px+1] += this.vel[px+1]*dt;
          this.pos[px+2] += this.vel[px+2]*dt;
        }

        // compact dead tail occasionally
        if(this.count > this.max*0.85){
          let write=0;
          for(let read=0;read<this.count;read++){
            if(this.life[read] <= 0) continue;
            if(write !== read){
              this.pos.set(this.pos.subarray(read*3, read*3+3), write*3);
              this.vel.set(this.vel.subarray(read*3, read*3+3), write*3);
              this.col.set(this.col.subarray(read*3, read*3+3), write*3);
              this.life[write] = this.life[read];
              this.seed[write] = this.seed[read];
            }
            write++;
          }
          this.count=write;
        }

        this.points.geometry.attributes.position.needsUpdate = true;
        this.points.geometry.attributes.aVel.needsUpdate = true;
        this.points.geometry.attributes.aLife.needsUpdate = true;
      }
    }

    class RedPacketConfetti {
      constructor(max=IS_MOBILE?1400:2200){
        this.max=max;
        this.count=0;
        this.pos = new Float32Array(max*3);
        this.vel = new Float32Array(max*3);
        this.life= new Float32Array(max);
        this.seed= new Float32Array(max);

        const geo = new THREE.BufferGeometry();
        geo.setAttribute("position", new THREE.BufferAttribute(this.pos,3));
        geo.setAttribute("aLife", new THREE.BufferAttribute(this.life,1));
        geo.setAttribute("aSeed", new THREE.BufferAttribute(this.seed,1));

        const tex = makeEnvelopeTexture(256,256);

        this.mat = new THREE.ShaderMaterial({
          transparent:true,
          depthWrite:false,
          blending:THREE.AdditiveBlending,
          uniforms:{
            uTime:{value:0},
            uTex:{value:tex},
            uSize:{value: IS_MOBILE? 1.05: 1.15}
          },
          vertexShader: /* glsl */`
            uniform float uTime;
            uniform float uSize;
            attribute float aLife;
            attribute float aSeed;
            varying float vLife;
            varying float vSeed;
            void main(){
              vLife = aLife;
              vSeed = aSeed;
              vec4 mv = modelViewMatrix * vec4(position,1.0);
              gl_Position = projectionMatrix * mv;
              float dist = max(0.001, -mv.z);
              float tw = 0.85 + 0.15*sin(uTime*5.0 + aSeed*10.0);
              gl_PointSize = clamp(uSize * tw * (78.0 / dist) * (0.45 + 0.55*aLife), 1.0, 9.0);
            }
          `,
          fragmentShader: /* glsl */`
            precision highp float;
            uniform sampler2D uTex;
            varying float vLife;
            varying float vSeed;
            void main(){
              vec2 uv = gl_PointCoord;
              vec4 t = texture2D(uTex, uv);
              float a = t.a * vLife * 0.65;
              if(a < 0.02) discard;
              // slight gold lift
              vec3 col = t.rgb;
              col = mix(col, col*vec3(1.10,1.05,0.92), 0.55);
              gl_FragColor = vec4(col, a);
            }
          `
        });

        this.points = new THREE.Points(geo, this.mat);
        this.points.layers.enable(BLOOM_LAYER);
        scene.add(this.points);
        this.power = 0.0;
      }

      emit(power=1.0){
        this.power = Math.max(this.power, power);
      }

      update(dt, time){
        this.mat.uniforms.uTime.value = time;

        // spawn while power>0
        if(this.power > 0){
          const spawn = Math.floor((IS_MOBILE? 18: 28) * this.power);
          for(let i=0;i<spawn;i++){
            if(this.count >= this.max) break;
            const idx=this.count++;

            const x = randRange(-4.2,4.2);
            const y = randRange(5.5,7.5);
            const z = randRange(-2.2,2.2);

            const vx = randRange(-0.6,0.6);
            const vy = randRange(-1.2,-0.2);
            const vz = randRange(-0.5,0.5);

            this.pos[idx*3+0]=x;
            this.pos[idx*3+1]=y;
            this.pos[idx*3+2]=z;

            this.vel[idx*3+0]=vx;
            this.vel[idx*3+1]=vy;
            this.vel[idx*3+2]=vz;

            this.life[idx]=1.0;
            this.seed[idx]=Math.random()*1000;
          }
          this.power = Math.max(0, this.power - dt*0.65);
          this.points.geometry.attributes.position.needsUpdate = true;
          this.points.geometry.attributes.aLife.needsUpdate = true;
          this.points.geometry.attributes.aSeed.needsUpdate = true;
        }

        const g=-1.8;
        const drag=0.992;

        for(let i=0;i<this.count;i++){
          let life=this.life[i];
          if(life<=0) continue;

          life -= dt*(0.35 + 0.25*Math.random());
          this.life[i]=life;

          const p=i*3;
          this.vel[p+1]+=g*dt;

          this.vel[p+0]*=Math.pow(drag, dt*60.0);
          this.vel[p+1]*=Math.pow(drag, dt*60.0);
          this.vel[p+2]*=Math.pow(drag, dt*60.0);

          this.pos[p+0]+=this.vel[p+0]*dt;
          this.pos[p+1]+=this.vel[p+1]*dt;
          this.pos[p+2]+=this.vel[p+2]*dt;
        }

        // compact
        if(this.count > this.max*0.85){
          let write=0;
          for(let read=0;read<this.count;read++){
            if(this.life[read] <= 0) continue;
            if(write !== read){
              this.pos.set(this.pos.subarray(read*3, read*3+3), write*3);
              this.vel.set(this.vel.subarray(read*3, read*3+3), write*3);
              this.life[write]=this.life[read];
              this.seed[write]=this.seed[read];
            }
            write++;
          }
          this.count=write;
        }

        this.points.geometry.attributes.position.needsUpdate = true;
        this.points.geometry.attributes.aLife.needsUpdate = true;
      }
    }

    const fireworks = new FireworksSystem();
    const confetti  = new RedPacketConfetti();

    // ---------------------------
    // Camera control (hand-driven + touch fallback)
    // ---------------------------
    let yaw=0.0, pitch=0.18, radius=12.0;     // 更远：能看到字全貌
    let yawT=yaw, pitchT=pitch;

    function applyCamera(dt, time){
      // subtle auto rotate in cluster, slower in others
      if(mode === Mode.CLUSTER){
        yawT += dt*0.18;
        pitchT = damp(pitchT, 0.14, 2.6, dt);
        radius = damp(radius, 12.2, 2.2, dt);
      } else if(mode === Mode.SCATTER){
        pitchT = clamp(pitchT, -0.22, 0.62);
        radius = damp(radius, 12.0, 2.2, dt);
      } else {
        // reveal: slightly closer but still see context
        pitchT = damp(pitchT, 0.14, 3.0, dt);
        radius = damp(radius, 11.2, 2.2, dt);
      }

      yaw = damp(yaw, yawT, 6.2, dt);
      pitch = damp(pitch, pitchT, 6.2, dt);

      const r=radius;
      const cx = Math.sin(yaw)*Math.cos(pitch)*r;
      const cy = 2.45 + Math.sin(pitch)*r*0.34;
      const cz = Math.cos(yaw)*Math.cos(pitch)*r;

      camera.position.set(cx,cy,cz);
      camera.lookAt(0,2.35,0);

      goldPoint.position.set(
        Math.sin(yaw*0.7)*2.0,
        5.0 + Math.sin(time*0.7)*0.14,
        2.6 + Math.cos(yaw*0.7)*1.4
      );
    }

    // touch fallback
    let dragging=false, lastX=0, lastY=0, lastTap=0;
    canvas.addEventListener("pointerdown",(e)=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
    window.addEventListener("pointerup",()=>dragging=false);
    window.addEventListener("pointermove",(e)=>{
      if(!dragging) return;
      const dx=e.clientX-lastX;
      const dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;
      if(mode !== Mode.SCATTER) return;
      yawT += dx*0.0042;
      pitchT += dy*0.0034;
    });
    canvas.addEventListener("click",()=>{
      const now=performance.now();
      if(now-lastTap < 360){
        // double click => grab envelope
        if(mode === Mode.SCATTER) triggerGrab();
        else if(mode === Mode.REVEAL) triggerGrab(); //换一个
      }
      lastTap=now;
    });

    // ---------------------------
    // Gesture (MediaPipe Hands)
    // ---------------------------
    let hands=null;
    let handEnabled=false;
    let lastLandmarks=null;
    let lastLandmarksTs=0;

    let grabDown=false;
    let grabCooldown=0;

    function dist3(a,b){
      const dx=a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0);
      return Math.sqrt(dx*dx+dy*dy+dz*dz);
    }

    function extended(landmarks, tip, pip){
      const wrist=landmarks[0];
      const dt = dist3(landmarks[tip], wrist);
      const dp = dist3(landmarks[pip], wrist);
      return dt > dp*1.12;
    }

    function computeGesture(landmarks){
      const wrist=landmarks[0];

      // hand size
      const handSize = Math.max(1e-6, dist3(wrist, landmarks[9]));

      // palm center
      const palmIdx=[0,5,9,13,17];
      const palm={x:0,y:0,z:0};
      for(const i of palmIdx){ palm.x+=landmarks[i].x; palm.y+=landmarks[i].y; palm.z+=(landmarks[i].z||0); }
      palm.x/=palmIdx.length; palm.y/=palmIdx.length; palm.z/=palmIdx.length;

      // finger extended count
      const thumbExt  = extended(landmarks,4,2);
      const indexExt  = extended(landmarks,8,6);
      const middleExt = extended(landmarks,12,10);
      const ringExt   = extended(landmarks,16,14);
      const pinkyExt  = extended(landmarks,20,18);
      const extCount = [thumbExt,indexExt,middleExt,ringExt,pinkyExt].filter(Boolean).length;

      // open/close
      const openHand = (extCount >= 4);
      const closeHand = (extCount <= 1);

      // palm roll: use MCP(5) to MCP(17) vector angle
      const a = landmarks[5], b=landmarks[17];
      const roll = Math.atan2((b.y-a.y), (b.x-a.x)); // change -> camera yaw

      // three-finger grab: thumb+index+middle tips close, ring+pinky folded (更像三指抓)
      const dTI = dist3(landmarks[4], landmarks[8]) / handSize;
      const dTM = dist3(landmarks[4], landmarks[12]) / handSize;
      const dIM = dist3(landmarks[8], landmarks[12]) / handSize;

      const threeGrab = (dTI < 0.38 && dTM < 0.42 && dIM < 0.40) && (!ringExt && !pinkyExt);

      return { palm, roll, openHand, closeHand, threeGrab };
    }

    let lastPalmX=null, lastPalmY=null, lastRoll=null;

    function handleGesture(g, dt){
      // state switching
      if(g.closeHand) setMode(Mode.CLUSTER);
      else if(g.openHand) setMode(Mode.SCATTER);

      // rotation control in scatter: palm move + roll
      if(mode === Mode.SCATTER && !g.threeGrab && !g.closeHand){
        if(lastPalmX != null){
          const dx = g.palm.x - lastPalmX;
          const dy = g.palm.y - lastPalmY;
          yawT   += (-dx) * 4.0;
          pitchT += ( dy) * 2.8;
        }
        if(lastRoll != null){
          const dr = g.roll - lastRoll;
          yawT += (-dr) * 0.85; // roll assist
        }
        lastPalmX=g.palm.x; lastPalmY=g.palm.y;
        lastRoll=g.roll;
      } else {
        lastPalmX=lastPalmY=lastRoll=null;
      }

      // grab detection with cooldown
      grabCooldown = Math.max(0, grabCooldown - dt);
      const pressed = g.threeGrab && grabCooldown <= 0;

      if(pressed && !grabDown){
        grabDown = true;
        triggerGrab();
        grabCooldown = 0.55;
      }
      if(!g.threeGrab) grabDown=false;
    }

    async function startHands(){
      if(!window.Hands){
        setStatus("MediaPipe Hands 未加载（请检查网络）。");
        return;
      }
      if(!navigator.mediaDevices?.getUserMedia){
        setStatus("当前浏览器不支持相机调用。");
        return;
      }

      hands = new window.Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
      });
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });

      hands.onResults((results)=>{
        const lm = results.multiHandLandmarks?.[0] || null;
        if(lm){
          lastLandmarks = lm;
          lastLandmarksTs = performance.now();
        }
      });

      const stream = await navigator.mediaDevices.getUserMedia({
        audio:false,
        video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} }
      });

      videoCamEl.srcObject = stream;
      await videoCamEl.play();

      handEnabled=true;
      led.classList.add("on");
      setStatus("手势识别已启用：握拳/张开/三指抓/旋转。");

      let busy=false, lastSent=0;
      async function pump(){
        if(!handEnabled) return;
        const now=performance.now();
        if(!busy && (now-lastSent)>33){
          busy=true;
          lastSent=now;
          try { await hands.send({ image: videoCamEl }); } catch(e){}
          busy=false;
        }
        requestAnimationFrame(pump);
      }
      pump();
    }

    btnStart.addEventListener("click", async ()=>{
      try{
        btnStart.disabled=true;
        btnStart.textContent="正在启用…";
        await startHands();
        btnStart.textContent="手势识别：已启用";
      }catch(e){
        setStatus("启用失败：请允许相机权限，并确保在 HTTPS / GitHub Pages 访问。");
        btnStart.disabled=false;
        btnStart.textContent="启用手势识别";
      }
    });

    btnHelp.addEventListener("click", ()=>{
      tipsEl.style.display = (tipsEl.style.display==="none") ? "flex" : "none";
    });

    btnReset.addEventListener("click", ()=>{
      setMode(Mode.CLUSTER);

      // reset envelopes
      for(let i=0;i<ENVELOPE_COUNT;i++){
        envHomeLocal[i] = sampleEnvelopeHomeLocal();
        envScatterWorld[i] = sampleEnvelopeScatterWorld();
        envPos[i].copy(envScatterWorld[i]);
        envVel[i].set(0,0,0);
      }

      // fireworks/confetti reset
      fireworks.count = 0;
      confetti.count = 0;

      // random idiom
      pickNewIdiom(true);

      // reset camera
      yaw=0.0; pitch=0.18; radius=12.0;
      yawT=yaw; pitchT=pitch;

      setStatus("已重置：合拢态（随机成语）");
    });

    // ---------------------------
    // Grab / Reveal logic
    // ---------------------------
    async function loadRandomHorseVideo(){
      const url = choose(HORSE_VIDEOS);

      // If file missing, browser will fail silently; we still show UI.
      horseVideo.src = url + `?v=${Date.now()}`;
      horseVideo.muted = true;
      horseVideo.loop = true;
      horseVideo.playsInline = true;

      try{
        horseVideo.load();
        safePlayVideo(horseVideo);
      }catch(e){}
    }

    function triggerGrab(){
      // In scatter => go reveal, in reveal => pick another
      if(mode === Mode.SCATTER){
        pickNewIdiom(false);
        loadRandomHorseVideo();
        setMode(Mode.REVEAL);

        // close state then open
        envelopeCard.classList.remove("envOpen");
        envSeal.textContent = "开";
        focusTitleEl.textContent = "抓到一个红包";

        // auto open after a short beat
        window.setTimeout(()=>{
          envelopeCard.classList.add("envOpen");
          envSeal.textContent = "福";
          // more fireworks
          fireworks.burst(2);
          confetti.emit(1.0);
        }, 280);

      } else if(mode === Mode.REVEAL){
        pickNewIdiom(false);
        loadRandomHorseVideo();

        envelopeCard.classList.remove("envOpen");
        envSeal.textContent = "开";
        focusTitleEl.textContent = "又抓到一个红包";

        window.setTimeout(()=>{
          envelopeCard.classList.add("envOpen");
          envSeal.textContent = "福";
          fireworks.burst(2);
          confetti.emit(0.85);
        }, 260);
      }
    }

    // click seal to open immediately (nice on desktop)
    envSeal.addEventListener("click", ()=>{
      if(mode !== Mode.REVEAL) return;
      envelopeCard.classList.add("envOpen");
      envSeal.textContent = "福";
      fireworks.burst(2);
      confetti.emit(1.0);
      safePlayVideo(horseVideo);
    });

    // ---------------------------
    // Background mood params
    // ---------------------------
    function updateMood(dt){
      if(mode === Mode.CLUSTER){
        bloomPass.strength = damp(bloomPass.strength, 1.12, 2.8, dt);
        bloomPass.radius   = damp(bloomPass.radius,   0.60, 2.8, dt);
        bloomPass.threshold= damp(bloomPass.threshold,0.16, 2.8, dt);
        fog.density        = damp(fog.density,        0.072,2.2, dt);
        renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.08, 2.2, dt);
      } else if(mode === Mode.SCATTER){
        bloomPass.strength = damp(bloomPass.strength, 1.22, 2.8, dt);
        bloomPass.radius   = damp(bloomPass.radius,   0.66, 2.8, dt);
        bloomPass.threshold= damp(bloomPass.threshold,0.15, 2.8, dt);
        fog.density        = damp(fog.density,        0.066,2.2, dt);
        renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.10, 2.2, dt);
      } else {
        bloomPass.strength = damp(bloomPass.strength, 1.28, 2.8, dt);
        bloomPass.radius   = damp(bloomPass.radius,   0.72, 2.8, dt);
        bloomPass.threshold= damp(bloomPass.threshold,0.14, 2.8, dt);
        fog.density        = damp(fog.density,        0.062,2.2, dt);
        renderer.toneMappingExposure = damp(renderer.toneMappingExposure, 1.12, 2.2, dt);
      }
    }

    // ---------------------------
    // Boot: initial tips
    // ---------------------------
    setStatus("默认：合拢态（握拳/张开/三指抓）。建议点“启用手势识别”。");

    // ---------------------------
    // Render loop
    // ---------------------------
    let lastTime = performance.now();
    let perfTime = 0;

    // periodic fireworks in REVEAL
    let fireTimer = 0;

    function animate(){
      const now = performance.now();
      const dt = clamp((now - lastTime)/1000, 0.0, 0.035);
      lastTime = now;
      perfTime += dt;

      // gesture
      if(handEnabled && lastLandmarks && (now - lastLandmarksTs) < 180){
        const g = computeGesture(lastLandmarks);
        handleGesture(g, dt);
      }

      // interpolate mode params
      mix = damp(mix, targetMix, 2.8, dt);
      reveal = damp(reveal, targetReveal, 4.2, dt);

      // idiom self-rotation around Y
      const spinSpeed = (1.0 - mix)*0.55 + mix*0.18;
      idiomGroup.rotation.y = perfTime * spinSpeed;

      // update shaders
      idiomMat.uniforms.uTime.value = perfTime;
      idiomMat.uniforms.uMix.value = mix;
      idiomMat.uniforms.uReveal.value = reveal;

      // envelopes inertia update
      updateEnvelopes(perfTime, dt);

      // camera
      applyCamera(dt, perfTime);

      // mood
      updateMood(dt);

      // fireworks + confetti (stronger in reveal)
      fireTimer += dt;
      if(mode === Mode.REVEAL && fireTimer > 0.75){
        fireTimer = 0;
        fireworks.burst(1);
        confetti.emit(0.55);
      }
      fireworks.update(dt, perfTime);
      confetti.update(dt, perfTime);

      // bloom intensity: reduce a bit when reveal to avoid washing UI
      bloomMixPass.material.uniforms.uBloomIntensity.value = lerp(1.0, 0.30, reveal);

      // render: selective bloom
      camera.layers.set(BLOOM_LAYER);
      bloomComposer.render();

      camera.layers.set(0);
      finalComposer.render();

      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // ---------------------------
    // Resize
    // ---------------------------
    function onResize(){
      const w=window.innerWidth, h=window.innerHeight;
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
      renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio || 1));
      renderer.setSize(w,h,false);
      bloomComposer.setSize(w,h);
      finalComposer.setSize(w,h);
      bloomPass.setSize?.(w,h);
    }
    window.addEventListener("resize", onResize);

    // ---------------------------
    // UX: quick start with keyboard (desktop)
    // ---------------------------
    window.addEventListener("keydown",(e)=>{
      if(e.key === "1") setMode(Mode.CLUSTER);
      if(e.key === "2") setMode(Mode.SCATTER);
      if(e.key === "3") triggerGrab();
    });

    // Start in cluster
    setMode(Mode.CLUSTER);
  </script>
</body>
</html>
