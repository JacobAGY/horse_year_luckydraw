<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <title>马年祝福 · 成语粒子 · PNG 跑马 · 红包布朗漂浮 · 手势交互</title>

  <script async src="https://unpkg.com/es-module-shims@1.10.0/dist/es-module-shims.js"></script>
  <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>

  <script type="importmap-shim">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.182.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.182.0/examples/jsm/"
    }
  }
  </script>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

  <style>
    :root{
      --gold:#d4af37;
      --red:#b11226;
      --panel: rgba(10,10,12,.58);
      --panel2: rgba(4,6,9,.42);
      --line: rgba(212,175,55,.35);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
    }
    html,body{height:100%;margin:0;overflow:hidden;background:radial-gradient(120% 120% at 50% 30%, #14060a 0%, #070607 55%, #040405 100%);color:var(--text);font-family: ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    #app{position:fixed;inset:0;}
    canvas#gl{position:absolute;inset:0;width:100%;height:100%;display:block;touch-action:none;}
    .cinema-vignette{position:absolute;inset:0;pointer-events:none;background:radial-gradient(120% 120% at 50% 45%, rgba(0,0,0,0) 42%, rgba(0,0,0,.62) 100%),radial-gradient(90% 70% at 50% 0%, rgba(212,175,55,.14) 0%, rgba(0,0,0,0) 60%),linear-gradient(180deg, rgba(177,18,38,.12) 0%, rgba(0,0,0,0) 40%);mix-blend-mode:screen;opacity:.95;}
    .hud{position:absolute;left:12px;right:12px;top:12px;display:flex;gap:10px;align-items:flex-start;pointer-events:none;}
    .panel{pointer-events:auto;flex:1 1 auto;max-width:980px;padding:12px 12px 10px;border:1px solid var(--line);border-radius:14px;background:linear-gradient(180deg, var(--panel) 0%, var(--panel2) 100%);box-shadow:0 14px 40px rgba(0,0,0,.45);backdrop-filter:blur(10px);}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    .brand{display:flex;gap:10px;align-items:center;min-width:320px;}
    .badge{width:12px;height:12px;border-radius:999px;background:var(--gold);box-shadow:0 0 0 2px rgba(212,175,55,.18),0 0 18px rgba(212,175,55,.45);}
    .title{font-weight:800;letter-spacing:.3px;font-size:14px;line-height:1.2;}
    .subtitle{font-size:12px;color:var(--muted);margin-top:2px;}
    .controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-left:auto;}
    button{pointer-events:auto;appearance:none;border:1px solid rgba(212,175,55,.38);color:var(--text);background:linear-gradient(180deg, rgba(177,18,38,.35), rgba(0,0,0,.22));border-radius:12px;padding:10px 12px;font-size:12px;font-weight:800;letter-spacing:.2px;box-shadow:0 10px 24px rgba(0,0,0,.35);cursor:pointer;user-select:none;}
    button.secondary{border-color: rgba(255,255,255,.14);background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.18));color: rgba(255,255,255,.86);}
    button:disabled{opacity:.65;cursor:not-allowed;}
    .tips{margin-top:10px;padding-top:10px;border-top:1px solid rgba(212,175,55,.22);display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:rgba(255,255,255,.78);}
    .chip{border:1px solid rgba(255,255,255,.12);background: rgba(255,255,255,.06);border-radius:999px;padding:6px 10px;display:inline-flex;gap:8px;align-items:center;}
    .chip b{color:rgba(255,255,255,.92);font-weight:900;}
    .status{margin-left:auto;font-size:12px;color:rgba(255,255,255,.70);display:flex;align-items:center;gap:8px;}
    .led{width:8px;height:8px;border-radius:999px;background:rgba(255,255,255,.18);box-shadow:0 0 0 2px rgba(255,255,255,.06);}
    .led.on{background: var(--gold);box-shadow:0 0 0 2px rgba(212,175,55,.16), 0 0 16px rgba(212,175,55,.55);}

    .focusOverlay{position:absolute;inset:0;display:flex;align-items:flex-end;justify-content:center;padding:16px 12px 22px;pointer-events:none;opacity:0;transform:translate3d(0,10px,0);transition:opacity .25s ease, transform .25s ease;}
    .focusOverlay.show{opacity:1;transform:translate3d(0,0,0);}
    .focusCard{pointer-events:auto;width:min(900px, calc(100vw - 24px));border-radius:18px;border:1px solid rgba(212,175,55,.45);background: linear-gradient(180deg, rgba(0,0,0,.55), rgba(8,10,12,.66));box-shadow: 0 22px 70px rgba(0,0,0,.62);backdrop-filter: blur(12px);padding:14px 14px 12px;position:relative;overflow:hidden;}
    .focusTop{display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;position:relative;}
    .packet{width:150px;height:190px;border-radius:16px;background: linear-gradient(180deg, rgba(177,18,38,.98), rgba(120,8,22,.98));border:1px solid rgba(212,175,55,.55);box-shadow:0 18px 55px rgba(0,0,0,.6);position:relative;overflow:hidden;transform-origin:50% 0%;}
    .packet .seal{position:absolute;left:50%;top:54%;width:62px;height:62px;transform:translate(-50%,-50%);border-radius:999px;background: radial-gradient(circle at 30% 30%, rgba(255,245,220,.95), rgba(212,175,55,.92) 60%, rgba(90,60,10,.85) 100%);box-shadow:0 0 0 2px rgba(212,175,55,.20), 0 0 26px rgba(212,175,55,.45);}
    .packet .lid{position:absolute;left:0;top:0;width:100%;height:52%;background: linear-gradient(180deg, rgba(215,30,55,.98), rgba(140,10,30,.98));border-bottom:1px solid rgba(212,175,55,.35);transform-origin:50% 100%;transform: rotateX(0deg);}
    .packet.open .lid{animation: openLid .55s ease forwards;}
    @keyframes openLid{0%{transform: rotateX(0deg);}100%{transform: rotateX(-125deg);}}
    .focusTextWrap{flex:1 1 340px;min-width:260px;}
    .focusTitle{margin:0;font-size:15px;letter-spacing:.5px;font-weight:900;}
    .focusLine{margin:8px 0 0;font-size:14px;line-height:1.6;color: rgba(255,255,255,.88);white-space:pre-wrap;text-shadow: 0 0 18px rgba(212,175,55,.12);}
    .videoWrap{margin-top:12px;border-radius:16px;overflow:hidden;border:1px solid rgba(255,255,255,.12);box-shadow: 0 16px 46px rgba(0,0,0,.55);}
    .videoWrap video{width:100%;height:auto;display:block;background:#000;}
    .small{margin-top:10px;font-size:12px;color: rgba(255,255,255,.65);display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap;}
    .kbd{border:1px solid rgba(255,255,255,.14);background: rgba(255,255,255,.06);border-radius:10px;padding:6px 10px;}
    video#cam{position:absolute;right:12px;bottom:12px;width:120px;height:160px;opacity:0;pointer-events:none;}
  </style>
</head>

<body>
<div id="app">
  <canvas id="gl"></canvas>
  <div class="cinema-vignette"></div>

  <div class="hud">
    <div class="panel">
      <div class="row">
        <div class="brand">
          <span class="badge"></span>
          <div>
            <div class="title">马年祝福 · 成语粒子（收拢态）· PNG 跑马（散开态）· 红包布朗漂浮</div>
            <div class="subtitle">Three.js / WebGL · MediaPipe Hands · Bloom</div>
          </div>
        </div>

        <div class="controls">
          <button id="btnStart">启用手势识别</button>
          <button id="btnReset" class="secondary">重置</button>
          <button id="btnHelp" class="secondary">玩法提示</button>
        </div>

        <div class="status">
          <span id="led" class="led"></span>
          <span id="statusText">加载中：正在准备 PNG 跑马点云…</span>
        </div>
      </div>

      <div class="tips" id="tips" style="display:none;">
        <span class="chip"><b>五指握拳</b> → 丝滑收拢：稳定成语 + 绕Y轴旋转</span>
        <span class="chip"><b>张开五指</b> → 散开：PNG 跑马 + 银河环绕</span>
        <span class="chip"><b>三指捏合</b>（拇指+食指+中指）→ 抓红包</span>
        <span class="chip"><b>双击画面</b> → 抓红包（无手势备选）</span>
      </div>
    </div>
  </div>

  <div id="focusOverlay" class="focusOverlay">
    <div class="focusCard">
      <div class="focusTop">
        <div id="packet" class="packet">
          <div class="lid"></div>
          <div class="seal"></div>
        </div>
        <div class="focusTextWrap">
          <h3 id="focusTitle" class="focusTitle">红包到 · 好运到</h3>
          <div id="focusText" class="focusLine"></div>
        </div>
      </div>

      <div class="videoWrap">
        <video id="horseVideo" playsinline muted loop></video>
      </div>

      <div class="small">
        <span class="kbd">握拳：收拢（丝滑过渡）</span>
        <span class="kbd">张开：散开（PNG 跑马）</span>
        <span class="kbd">三指捏合 / 双击：抓红包</span>
      </div>
    </div>
  </div>

  <video id="cam" playsinline></video>
</div>

<script type="module-shim">
import * as THREE from "three";
import { EffectComposer } from "three/addons/postprocessing/EffectComposer.js";
import { RenderPass } from "three/addons/postprocessing/RenderPass.js";
import { UnrealBloomPass } from "three/addons/postprocessing/UnrealBloomPass.js";
import { OutputPass } from "three/addons/postprocessing/OutputPass.js";
import { ShaderPass } from "three/addons/postprocessing/ShaderPass.js";

/* ========= 基础数据 ========= */
const IDIOMS = [
  "马到成功","龙马精神","一马当先","万马奔腾","马上发财","马上如意",
  "策马扬鞭","快马加鞭","一马平川","天马行空","马到功成","马跃钱程",
  "人强马壮","金戈铁马","骏马奔腾","马蹄生风","马年大吉","金马迎春","马到福来"
];

// 你自己的跑马视频（可空）
const HORSE_VIDEOS = [
  "assets/videos/horse1.mp4",
  "assets/videos/horse2.mp4"
];

// ✅ 你的 PNG 跑马帧：a-f（按实际文件名改）
const HORSE_FRAMES = [
  "assets/horse_frames/horse_a.png",
  "assets/horse_frames/horse_b.png",
  "assets/horse_frames/horse_c.png",
  "assets/horse_frames/horse_d.png",
  "assets/horse_frames/horse_e.png",
  "assets/horse_frames/horse_f.png"
];

const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const DPR_CAP = IS_MOBILE ? 1.25 : 2.0;

const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp  = (a,b,t)=>a+(b-a)*t;
const damp  = (current, target, lambda, dt) => current + (target-current)*(1-Math.exp(-lambda*dt));

/* ========= DOM ========= */
const canvas = document.getElementById("gl");
const statusText = document.getElementById("statusText");
const led = document.getElementById("led");
const btnStart = document.getElementById("btnStart");
const btnReset = document.getElementById("btnReset");
const btnHelp = document.getElementById("btnHelp");
const tips = document.getElementById("tips");
const videoEl = document.getElementById("cam");

const focusOverlay = document.getElementById("focusOverlay");
const focusTitleEl = document.getElementById("focusTitle");
const focusTextEl = document.getElementById("focusText");
const packetEl = document.getElementById("packet");
const horseVideo = document.getElementById("horseVideo");

/* ========= Three 基础 ========= */
const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:false, powerPreference:"high-performance" });
renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio || 1));
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.08;

const scene = new THREE.Scene();
scene.background = new THREE.Color("#030304");

const camera = new THREE.PerspectiveCamera(52, window.innerWidth/window.innerHeight, 0.1, 160);
camera.position.set(0, 2.3, 10.4);

scene.add(new THREE.AmbientLight(0xffffff, 0.20));
const key = new THREE.DirectionalLight(0xfff2d6, 1.05); key.position.set(6,9,6); scene.add(key);
const goldPoint = new THREE.PointLight(0xd4af37, 1.25, 28, 2); goldPoint.position.set(0,5.2,3.2); scene.add(goldPoint);
const redPoint  = new THREE.PointLight(0xb11226, 0.85, 22, 2); redPoint.position.set(-2.8,3.4,2.6); scene.add(redPoint);

/* ========= 后期 Bloom ========= */
const BLOOM_LAYER = 1;

const bloomComposer = new EffectComposer(renderer);
bloomComposer.addPass(new RenderPass(scene, camera));
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.18, 0.62, 0.16);
bloomComposer.addPass(bloomPass);

const finalComposer = new EffectComposer(renderer);
finalComposer.addPass(new RenderPass(scene, camera));
const bloomMixPass = new ShaderPass(new THREE.ShaderMaterial({
  uniforms: { baseTexture:{value:null}, bloomTexture:{value:bloomComposer.renderTarget2.texture}, uBloomIntensity:{value:1.0} },
  vertexShader:`varying vec2 vUv;void main(){vUv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
  fragmentShader:`uniform sampler2D baseTexture;uniform sampler2D bloomTexture;uniform float uBloomIntensity;varying vec2 vUv;
  void main(){vec4 base=texture2D(baseTexture,vUv);vec4 bloom=texture2D(bloomTexture,vUv);gl_FragColor=base+bloom*uBloomIntensity;}`
}), "baseTexture");
finalComposer.addPass(bloomMixPass);
finalComposer.addPass(new OutputPass());

/* ========= 粒子纹理（马字） ========= */
function makeMaGlyphTexture(){
  const c=document.createElement("canvas"); c.width=256; c.height=256;
  const ctx=c.getContext("2d");
  ctx.clearRect(0,0,256,256);
  const g=ctx.createRadialGradient(128,128,0,128,128,118);
  g.addColorStop(0,"rgba(212,175,55,0.22)"); g.addColorStop(0.65,"rgba(212,175,55,0.06)"); g.addColorStop(1,"rgba(212,175,55,0)");
  ctx.fillStyle=g; ctx.fillRect(0,0,256,256);
  ctx.save(); ctx.translate(128,145);
  ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.font="900 160px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial";
  ctx.lineJoin="round"; ctx.lineWidth=10;
  ctx.strokeStyle="rgba(177,18,38,0.55)"; ctx.strokeText("马",0,0);
  ctx.fillStyle="rgba(255,245,220,0.92)"; ctx.fillText("马",0,0);
  ctx.restore();
  const tex=new THREE.CanvasTexture(c);
  tex.colorSpace=THREE.SRGBColorSpace; tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter; tex.generateMipmaps=false;
  return tex;
}
const MA_TEX = makeMaGlyphTexture();

/* ========= 文本采样（成语点位） ========= */
function sampleTextPoints2D(text, { fontSize=200, step=IS_MOBILE?3:2, threshold=10, worldWidth=7.8 } = {}){
  const dpr=Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const c=document.createElement("canvas");
  const ctx=c.getContext("2d", { willReadFrequently:true });
  const font=`900 ${fontSize}px ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial`;
  ctx.font=font;
  const metrics=ctx.measureText(text);
  const pad=Math.ceil(fontSize*0.46);
  const cssW=Math.ceil(metrics.width + pad*2);
  const cssH=Math.ceil(fontSize*1.32 + pad*2);
  c.width=Math.ceil(cssW*dpr); c.height=Math.ceil(cssH*dpr);
  ctx.setTransform(dpr,0,0,dpr,0,0);
  ctx.clearRect(0,0,cssW,cssH);
  ctx.font=font; ctx.textAlign="center"; ctx.textBaseline="middle";
  ctx.lineJoin="round"; ctx.lineWidth=Math.max(10, Math.round(fontSize*0.06));
  ctx.strokeStyle="rgba(177,18,38,1)"; ctx.strokeText(text, cssW/2, cssH/2);
  ctx.fillStyle="rgba(255,255,255,1)"; ctx.fillText(text, cssW/2, cssH/2);

  const img=ctx.getImageData(0,0,c.width,c.height).data;
  const pts=[];
  const stepPx=Math.max(1, Math.round(step*dpr));
  for(let y=0;y<c.height;y+=stepPx){
    for(let x=0;x<c.width;x+=stepPx){
      const a=img[(y*c.width+x)*4+3];
      if(a>threshold) pts.push([x/dpr, y/dpr]);
    }
  }
  const scale=worldWidth/cssW;
  const out=new Float32Array(pts.length*2);
  for(let i=0;i<pts.length;i++){
    const [xCss,yCss]=pts[i];
    out[i*2+0]=(xCss-cssW/2)*scale;
    out[i*2+1]=(cssH/2-yCss)*scale;
  }
  return out;
}

/* ========= PNG 贴纸采样为点云（关键新增） ========= */
function loadImage(url){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.decoding = "async";
    img.onload = ()=>resolve(img);
    img.onerror = ()=>reject(new Error("Failed to load image: " + url));
    img.src = url;
  });
}

function sampleCanvasPoints(canvas, {
  maxPoints=18000,
  threshold=10,
  step=IS_MOBILE?3:2,
  worldWidth=5.8,
  centerY=-0.25,
  thickness=0.95
} = {}){
  const W=canvas.width, H=canvas.height;
  const ctx=canvas.getContext("2d", { willReadFrequently:true });
  const data=ctx.getImageData(0,0,W,H).data;

  const candidates=[];
  for(let y=0;y<H;y+=step){
    for(let x=0;x<W;x+=step){
      const a=data[(y*W+x)*4+3];
      if(a>threshold) candidates.push([x,y]);
    }
  }

  const n=Math.min(maxPoints, candidates.length);
  for(let i=0;i<n;i++){
    const j=i + ((Math.random()*(candidates.length-i))|0);
    const t=candidates[i]; candidates[i]=candidates[j]; candidates[j]=t;
  }

  const scale=worldWidth/W;
  const out=new Float32Array(n*3);
  for(let i=0;i<n;i++){
    const x=candidates[i][0], y=candidates[i][1];
    const wx=(x - W/2)*scale;
    const wy=(H/2 - y)*scale + centerY;
    // 固定厚度（一次性随机，之后不会抖）
    const wz=(Math.random()+Math.random()-1)*(thickness*0.22) + (Math.random()+Math.random()-1)*(thickness*0.14);
    out[i*3+0]=wx; out[i*3+1]=wy; out[i*3+2]=wz;
  }
  return out;
}

/* ========= 模式 & 过渡 ========= */
const Mode = { MERGE:"MERGE", SCATTER:"SCATTER", FOCUS:"FOCUS" };
let mode = Mode.MERGE;
let mix = 0, targetMix = 0;      // 0=成语，1=散开马+银河
let focus = 0, targetFocus = 0;

function showFocusOverlay(){ focusOverlay.classList.add("show"); }
function hideFocusOverlay(){ focusOverlay.classList.remove("show"); packetEl.classList.remove("open"); }

function setMode(next){
  if(mode===next) return;
  mode=next;
  if(mode===Mode.MERGE){ targetMix=0; targetFocus=0; hideFocusOverlay(); }
  if(mode===Mode.SCATTER){ targetMix=1; targetFocus=0; hideFocusOverlay(); kickScatterImpulse(); }
  if(mode===Mode.FOCUS){ targetMix=1; targetFocus=1; showFocusOverlay(); }
}

/* ========= 成语粒子系统 ========= */
const idiomGroup = new THREE.Group();
idiomGroup.position.set(0, 2.25, 0);
scene.add(idiomGroup);

let envHomeRingR = 3.4;
let currentIdiom = "";

const MAX_PARTICLES = IS_MOBILE ? 16000 : 26000;

const idiomGeo = new THREE.BufferGeometry();
const aPos      = new Float32Array(MAX_PARTICLES*3);
const aVel      = new Float32Array(MAX_PARTICLES*3);
const aIdiomTar = new Float32Array(MAX_PARTICLES*3);
const aSeed     = new Float32Array(MAX_PARTICLES);
const aKind     = new Float32Array(MAX_PARTICLES); // 0=horse, 1=galaxy
idiomGeo.setAttribute("position", new THREE.BufferAttribute(aPos,3));
idiomGeo.setAttribute("aVel", new THREE.BufferAttribute(aVel,3));
idiomGeo.setAttribute("aIdiomTar", new THREE.BufferAttribute(aIdiomTar,3));
idiomGeo.setAttribute("aSeed", new THREE.BufferAttribute(aSeed,1));
idiomGeo.setAttribute("aKind", new THREE.BufferAttribute(aKind,1));

for(let i=0;i<MAX_PARTICLES;i++){
  aPos[i*3+0]=(Math.random()-0.5)*6;
  aPos[i*3+1]=(Math.random()-0.5)*3;
  aPos[i*3+2]=(Math.random()-0.5)*6;
  aVel[i*3+0]=(Math.random()-0.5)*0.15;
  aVel[i*3+1]=(Math.random()-0.5)*0.15;
  aVel[i*3+2]=(Math.random()-0.5)*0.15;
  aSeed[i]=Math.random();
  aKind[i]=(aSeed[i] < 0.44) ? 0.0 : 1.0;
}

/* ========= PNG 帧点云：horseFramesPts[] ========= */
let horseFramesPts = [];      // 每帧 Float32Array xyz...
let horseFrameN = 1;          // 点数（按第0帧）
let horseReady = false;
const horseIdx = new Uint32Array(MAX_PARTICLES);

function initHorseIndexMapping(){
  horseFrameN = Math.max(1, horseFramesPts[0] ? (horseFramesPts[0].length/3) : 1);
  for(let i=0;i<MAX_PARTICLES;i++){
    if(aKind[i] === 0.0){
      // 固定映射：每个马粒子固定一个点索引，保证“像马且稳定”
      horseIdx[i] = (Math.random() * horseFrameN) | 0;
    }
  }
}

async function buildHorsePointCloudsFromPNGs(){
  const imgs = await Promise.all(HORSE_FRAMES.map(loadImage));
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently:true });

  // 统一用最大尺寸，避免帧间点位比例变化
  let W=0,H=0;
  for(const img of imgs){ W=Math.max(W, img.naturalWidth); H=Math.max(H, img.naturalHeight); }
  // 如果你的 PNG 很大，这里会自动压一下，提升性能
  const maxSide = IS_MOBILE ? 1000 : 1400;
  const scale = Math.min(1, maxSide / Math.max(W,H));
  canvas.width = Math.max(2, Math.floor(W*scale));
  canvas.height= Math.max(2, Math.floor(H*scale));

  const maxPts = IS_MOBILE ? 11000 : 19000;

  horseFramesPts = [];
  for(let k=0;k<imgs.length;k++){
    ctx.clearRect(0,0,canvas.width, canvas.height);
    // 居中绘制（防止帧尺寸不一导致“跳”）
    const dw = imgs[k].naturalWidth * scale;
    const dh = imgs[k].naturalHeight* scale;
    const dx = (canvas.width - dw)/2;
    const dy = (canvas.height- dh)/2;
    ctx.drawImage(imgs[k], dx, dy, dw, dh);

    const pts = sampleCanvasPoints(canvas, {
      maxPoints: maxPts,
      step: IS_MOBILE ? 3 : 2,
      worldWidth: IS_MOBILE ? 5.0 : 5.9,
      centerY: -0.25,
      thickness: IS_MOBILE ? 0.72 : 0.95
    });

    horseFramesPts.push(pts);
  }

  initHorseIndexMapping();
  horseReady = true;
}

/* ========= 成语目标：只在触发时重建，保证稳定 ========= */
function pickIdiom(){ return IDIOMS[(Math.random()*IDIOMS.length)|0]; }

function rebuildIdiomTargets(text){
  currentIdiom = text;
  const pts2 = sampleTextPoints2D(text, { fontSize: IS_MOBILE?190:210, step: IS_MOBILE?3:2, worldWidth: IS_MOBILE?7.0:8.2 });
  const targetN = Math.max(1, Math.floor(pts2.length/2));
  const thickness = IS_MOBILE ? 0.55 : 0.85;

  for(let i=0;i<MAX_PARTICLES;i++){
    const idx = (i % targetN) * 2;
    const x = pts2[idx+0], y = pts2[idx+1];
    const z = (aSeed[i]-0.5)*thickness + (aSeed[i]*aSeed[i]-0.33)*thickness*0.25;
    aIdiomTar[i*3+0]=x; aIdiomTar[i*3+1]=y; aIdiomTar[i*3+2]=z;
  }
  idiomGeo.attributes.aIdiomTar.needsUpdate = true;

  // 粗估包围半径（给红包环）
  let minX=1e9,maxX=-1e9,minY=1e9,maxY=-1e9;
  for(let k=0;k<pts2.length;k+=2){
    const x=pts2[k], y=pts2[k+1];
    if(x<minX) minX=x; if(x>maxX) maxX=x;
    if(y<minY) minY=y; if(y>maxY) maxY=y;
  }
  const w=Math.max(2.0,(maxX-minX)), h=Math.max(1.2,(maxY-minY));
  envHomeRingR = clamp(Math.max(w,h)*0.62*1.10, 2.8, 5.6);
}

rebuildIdiomTargets(pickIdiom());

const idiomMat = new THREE.ShaderMaterial({
  transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
  uniforms:{ uTime:{value:0}, uMix:{value:0}, uFocus:{value:0}, uMap:{value:MA_TEX} },
  vertexShader:`
    uniform float uTime; uniform float uMix; uniform float uFocus;
    attribute vec3 aVel; attribute vec3 aIdiomTar; attribute float aSeed; attribute float aKind;
    varying float vSeed; varying float vGlow;
    void main(){
      vSeed=aSeed;
      vec3 p=position;

      // 收拢态微动更小，稳定观感
      float wob=mix(0.10,0.30,uMix);
      float t=uTime*(0.65 + aSeed*1.25);
      p.x += cos(t + aSeed*12.0) * (0.010 + aSeed*0.020) * wob;
      p.y += sin(t*0.9 + aSeed*10.0) * (0.012 + aSeed*0.024) * wob;
      p.z += sin(t*1.1 + aSeed* 8.0) * (0.010 + aSeed*0.020) * wob;

      p *= (1.0 + uFocus*(0.05 + aSeed*0.10));

      vec4 mv=modelViewMatrix*vec4(p,1.0);
      gl_Position=projectionMatrix*mv;

      float dist=max(0.001, -mv.z);
      float base=0.95;
      float tw=0.90 + 0.10*sin(uTime*2.1 + aSeed*9.0);
      float size=mix(1.00,1.10,uMix);
      gl_PointSize=clamp(base*tw*size*(120.0/dist), 0.65, 2.30);

      vGlow=0.55 + 0.45*sin(uTime*2.0 + aSeed*11.0);
    }
  `,
  fragmentShader:`
    precision highp float;
    uniform sampler2D uMap;
    varying float vSeed; varying float vGlow;
    void main(){
      vec4 m=texture2D(uMap, gl_PointCoord);
      if(m.a < 0.06) discard;

      vec3 gold=vec3(0.83,0.69,0.22);
      vec3 red =vec3(0.70,0.07,0.15);
      vec3 warm=vec3(1.00,0.92,0.72);

      float k=smoothstep(0.20, 0.95, vSeed);
      vec3 col=mix(warm, gold, k);
      col=mix(col, red, smoothstep(0.78,0.98,vSeed)*0.45);

      float a=m.a*(0.52 + 0.62*vGlow);
      gl_FragColor=vec4(col*(1.10 + 0.65*m.a), a);
    }
  `
});

const idiomPoints = new THREE.Points(idiomGeo, idiomMat);
idiomPoints.frustumCulled=false;
idiomPoints.layers.enable(BLOOM_LAYER);
idiomGroup.add(idiomPoints);

/* ========= 红包系统（缩小一半 + 大小不一 + 布朗漂浮） ========= */
function makeRedEnvelopeTexture(){
  const c=document.createElement("canvas"); c.width=256; c.height=320;
  const ctx=c.getContext("2d");
  const g=ctx.createLinearGradient(0,0,0,320);
  g.addColorStop(0,"#d01a35"); g.addColorStop(1,"#7b081a");
  ctx.fillStyle=g; ctx.fillRect(0,0,256,320);
  ctx.strokeStyle="rgba(212,175,55,.85)"; ctx.lineWidth=10; ctx.strokeRect(14,14,228,292);
  for(let i=0;i<18;i++){
    const x=Math.random()*256, y=Math.random()*320, r=18+Math.random()*46;
    ctx.beginPath(); ctx.fillStyle=`rgba(212,175,55,${0.04+Math.random()*0.06})`; ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }
  ctx.save(); ctx.translate(128,190);
  ctx.beginPath(); ctx.fillStyle="rgba(212,175,55,.92)"; ctx.arc(0,0,42,0,Math.PI*2); ctx.fill();
  ctx.fillStyle="rgba(90,60,10,.80)"; ctx.font="900 54px ui-sans-serif, system-ui, -apple-system";
  ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText("福",0,2);
  ctx.restore();
  const tex=new THREE.CanvasTexture(c);
  tex.colorSpace=THREE.SRGBColorSpace; tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter; tex.generateMipmaps=false;
  return tex;
}
const ENV_TEX = makeRedEnvelopeTexture();

const ENVELOPES = IS_MOBILE ? 160 : 260;
const envGroup = new THREE.Group();
idiomGroup.add(envGroup);

const envGeo = new THREE.PlaneGeometry(0.14, 0.18); // 缩小一半
const envMat = new THREE.MeshBasicMaterial({ map: ENV_TEX, transparent:true, opacity:0.98, depthWrite:false, toneMapped:false });
const envMesh = new THREE.InstancedMesh(envGeo, envMat, ENVELOPES);
envMesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
envMesh.layers.enable(BLOOM_LAYER);
envGroup.add(envMesh);

const envHomeLocal = new Array(ENVELOPES);
const envScatterWorld = new Array(ENVELOPES);
const envVelWorld = new Array(ENVELOPES);
const envScale = new Array(ENVELOPES);
const envSeed = new Array(ENVELOPES);

function sampleEnvelopeHomeLocal(i){
  const ang=(i/ENVELOPES)*Math.PI*2 + (Math.random()-0.5)*0.35;
  const r=envHomeRingR*(0.86 + Math.random()*0.52);
  const y=(Math.random()-0.5)*1.9;
  const z=(Math.random()-0.5)*1.7;
  return new THREE.Vector3(Math.cos(ang)*r, y, z);
}
function sampleScatterWorld(){
  const R=7.2;
  const u=Math.random(), v=Math.random();
  const theta=u*Math.PI*2;
  const phi=Math.acos(2*v-1);
  const rr=(0.45 + Math.pow(Math.random(),0.65)*0.55)*R;
  return new THREE.Vector3(
    rr*Math.sin(phi)*Math.cos(theta),
    rr*Math.cos(phi)*0.75 + 2.2,
    rr*Math.sin(phi)*Math.sin(theta)
  );
}
for(let i=0;i<ENVELOPES;i++){
  envHomeLocal[i]=sampleEnvelopeHomeLocal(i);
  envScatterWorld[i]=sampleScatterWorld();
  envVelWorld[i]=new THREE.Vector3(0,0,0);
  const sizeTier=Math.random();
  envScale[i]=(sizeTier<0.18)?lerp(0.45,0.70,Math.random())
           :(sizeTier<0.78)?lerp(0.70,1.05,Math.random())
           :                 lerp(1.05,1.55,Math.random());
  envSeed[i]=Math.random()*1000;
}
const _obj = new THREE.Object3D();
const _tmp = new THREE.Vector3();
const _homeWorld = new THREE.Vector3();

function brown3(seed,t){
  const a=Math.sin(t*0.55 + seed*1.3);
  const b=Math.sin(t*0.93 + seed*2.1);
  const c=Math.sin(t*1.37 + seed*3.7);
  const d=Math.sin(t*0.71 + seed*5.2);
  return { x:a*0.38 + b*0.22, y:c*0.34 + a*0.16, z:d*0.38 + b*0.18 };
}

function updateEnvelopes(time, dt){
  idiomGroup.updateMatrixWorld(true);

  for(let i=0;i<ENVELOPES;i++){
    const seed=envSeed[i];
    const n=brown3(seed, time);
    _homeWorld.copy(envHomeLocal[i]);
    _homeWorld.x += n.x*0.22;
    _homeWorld.y += n.y*0.22;
    _homeWorld.z += n.z*0.22;

    const sW=envScatterWorld[i];
    const vW=envVelWorld[i];

    vW.multiplyScalar(Math.pow(0.92, dt*60));
    sW.addScaledVector(vW, dt);
    sW.x += Math.sin(time*0.40 + seed)*0.010;
    sW.y += Math.sin(time*0.55 + seed)*0.012;
    sW.z += Math.sin(time*0.48 + seed)*0.010;

    _tmp.copy(_homeWorld).applyMatrix4(idiomGroup.matrixWorld);

    const x=lerp(_tmp.x, sW.x, mix);
    const y=lerp(_tmp.y, sW.y, mix);
    const z=lerp(_tmp.z, sW.z, mix);

    _obj.position.set(x,y,z);
    _obj.quaternion.copy(camera.quaternion);
    _obj.rotateZ(Math.sin(time*0.35 + seed)*0.10);
    const s=envScale[i]*(1.0 - focus*0.10);
    _obj.scale.setScalar(s);
    _obj.updateMatrix();
    envMesh.setMatrixAt(i, _obj.matrix);
  }
  envMesh.instanceMatrix.needsUpdate=true;
}

function kickScatterImpulse(){
  const centerW=new THREE.Vector3(0,0,0).applyMatrix4(idiomGroup.matrixWorld);
  for(let i=0;i<ENVELOPES;i++){
    const p=envScatterWorld[i];
    const dir=new THREE.Vector3().subVectors(p, centerW).normalize();
    dir.x += (Math.random()-0.5)*0.35;
    dir.y += (Math.random()-0.2)*0.25;
    dir.z += (Math.random()-0.5)*0.35;
    dir.normalize();
    const kick=2.0 + Math.random()*3.6;
    envVelWorld[i].addScaledVector(dir, kick);
  }
  // 粒子也给一点冲量（一次性）
  for(let i=0;i<MAX_PARTICLES;i++){
    const sx=(Math.random()-0.5), sy=(Math.random()-0.2), sz=(Math.random()-0.5);
    const len=Math.max(1e-4, Math.sqrt(sx*sx+sy*sy+sz*sz));
    const k=0.75 + Math.random()*1.75;
    aVel[i*3+0] += (sx/len)*k;
    aVel[i*3+1] += (sy/len)*k;
    aVel[i*3+2] += (sz/len)*k;
  }
  idiomGeo.attributes.aVel.needsUpdate=true;
}

/* ========= 散开态目标：PNG 跑马 + 银河 ========= */
function horseTargetFromPNGs(i, time){
  if(!horseReady || horseFramesPts.length===0) return [0,0,0];

  // 跑步帧率：你可调 10~14 更自然
  const fps = 12.0;
  const f = (time * fps) % horseFramesPts.length;
  const i0 = Math.floor(f);
  const i1 = (i0 + 1) % horseFramesPts.length;
  const t = f - i0;

  const pts0 = horseFramesPts[i0];
  const pts1 = horseFramesPts[i1];
  const n = horseFrameN;

  const idx = horseIdx[i] % n;
  const ax=pts0[idx*3+0], ay=pts0[idx*3+1], az=pts0[idx*3+2];
  const bx=pts1[idx*3+0], by=pts1[idx*3+1], bz=pts1[idx*3+2];

  let x = ax + (bx-ax)*t;
  let y = ay + (by-ay)*t;
  let z = az + (bz-az)*t;

  // 轻微整体起伏（不破形）
  const run = time*6.0;
  y += Math.sin(run)*0.05;
  x += Math.sin(run*0.5)*0.03;

  return [x,y,z];
}

function galaxyTarget(i, time){
  const s=aSeed[i];
  const r=lerp(2.8, 5.6, Math.pow(s, 0.55));
  const ang=time*(0.42 + s*0.30) + s*18.0;
  const y=(Math.sin(time*0.65 + s*9.0)*0.55) + (s-0.5)*1.2;
  const x=Math.cos(ang)*r;
  const z=Math.sin(ang)*r + (s-0.5)*0.85;
  return [x,y,z];
}

/* ========= 粒子物理更新（目标 = lerp(成语, 散开, mix)） ========= */
function updateIdiom(dt, time){
  if(mode===Mode.MERGE) idiomGroup.rotation.y += dt*0.22;
  else idiomGroup.rotation.y = damp(idiomGroup.rotation.y, 0.0, 3.0, dt);

  const spring=7.8, drag=3.8;

  for(let i=0;i<MAX_PARTICLES;i++){
    const px=aPos[i*3+0], py=aPos[i*3+1], pz=aPos[i*3+2];
    let vx=aVel[i*3+0], vy=aVel[i*3+1], vz=aVel[i*3+2];

    const itx=aIdiomTar[i*3+0], ity=aIdiomTar[i*3+1], itz=aIdiomTar[i*3+2];

    let stx=0, sty=0, stz=0;
    if(aKind[i] === 0.0){
      const h = horseTargetFromPNGs(i, time);
      stx=h[0]; sty=h[1]; stz=h[2];
    }else{
      const g = galaxyTarget(i, time);
      stx=g[0]; sty=g[1]; stz=g[2];
    }

    const tx=lerp(itx, stx, mix);
    const ty=lerp(ity, sty, mix);
    const tz=lerp(itz, stz, mix);

    vx += (tx-px)*spring*dt;
    vy += (ty-py)*spring*dt;
    vz += (tz-pz)*spring*dt;

    const dd=Math.exp(-drag*dt);
    vx*=dd; vy*=dd; vz*=dd;

    aPos[i*3+0]=px + vx*dt;
    aPos[i*3+1]=py + vy*dt;
    aPos[i*3+2]=pz + vz*dt;

    aVel[i*3+0]=vx; aVel[i*3+1]=vy; aVel[i*3+2]=vz;
  }

  idiomGeo.attributes.position.needsUpdate=true;
  idiomGeo.attributes.aVel.needsUpdate=true;
  idiomMat.uniforms.uTime.value=time;
  idiomMat.uniforms.uMix.value=mix;
  idiomMat.uniforms.uFocus.value=focus;
}

/* ========= 相机（散开态可拖动旋转） ========= */
let yaw=0.0, pitch=0.14, radius=10.4;
let yawT=yaw, pitchT=pitch;
let dragging=false, lastX=0, lastY=0, lastTap=0;

canvas.addEventListener("pointerdown",(e)=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
window.addEventListener("pointerup",()=>dragging=false);
window.addEventListener("pointermove",(e)=>{
  if(!dragging) return;
  if(mode!==Mode.SCATTER) return;
  const dx=e.clientX-lastX, dy=e.clientY-lastY;
  lastX=e.clientX; lastY=e.clientY;
  yawT += dx*0.0042;
  pitchT += dy*0.0032;
});
canvas.addEventListener("click", ()=>{
  const now=performance.now();
  if(now-lastTap<360) triggerRedPacketFlow(); // 双击抓红包
  lastTap=now;
});

function applyCamera(dt, time){
  if(mode===Mode.MERGE){
    yawT += dt*0.10;
    pitchT = damp(pitchT, 0.14, 2.8, dt);
  }else if(mode===Mode.FOCUS){
    pitchT = damp(pitchT, 0.12, 3.0, dt);
  }else{
    pitchT = clamp(pitchT, -0.22, 0.62);
  }

  yaw=damp(yaw,yawT,6.0,dt);
  pitch=damp(pitch,pitchT,6.0,dt);

  const r=radius;
  const cx=Math.sin(yaw)*Math.cos(pitch)*r;
  const cy=2.25 + Math.sin(pitch)*r*0.33;
  const cz=Math.cos(yaw)*Math.cos(pitch)*r;
  camera.position.set(cx,cy,cz);
  camera.lookAt(0,2.25,0);

  goldPoint.position.set(
    Math.sin(yaw*0.7)*2.0,
    5.0 + Math.sin(time*0.7)*0.12,
    3.0 + Math.cos(yaw*0.7)*1.2
  );
}

/* ========= 红包开封 ========= */
let focusLock=false;
function pickVideo(){ return HORSE_VIDEOS[(Math.random()*HORSE_VIDEOS.length)|0]; }

async function triggerRedPacketFlow(){
  if(mode!==Mode.SCATTER && mode!==Mode.FOCUS) return;
  if(focusLock) return;
  focusLock=true;

  if(mode!==Mode.FOCUS) setMode(Mode.FOCUS);

  const idiom=currentIdiom || pickIdiom();
  focusTitleEl.textContent="红包到 · 好运到";
  focusTextEl.textContent=`恭喜你抓到一个红包！\n\n${idiom}`;

  packetEl.classList.remove("open"); void packetEl.offsetWidth; packetEl.classList.add("open");

  try{
    const url=pickVideo();
    horseVideo.pause();
    horseVideo.src=url;
    horseVideo.load();
    await horseVideo.play().catch(()=>{});
  }catch(e){}

  setTimeout(()=>{ focusLock=false; }, 650);
}

/* ========= 手势识别（严格区分） ========= */
let hands=null;
let handEnabled=false;
let lastLandmarks=null;
let lastLandmarksTs=0;

function dist3(a,b){
  const dx=a.x-b.x, dy=a.y-b.y, dz=(a.z||0)-(b.z||0);
  return Math.sqrt(dx*dx+dy*dy+dz*dz);
}
function computeGesture(landmarks){
  const wrist=landmarks[0];
  const handSize=Math.max(1e-6, dist3(wrist, landmarks[9])); // wrist->middle_mcp

  function extended(tip,pip){
    const dt=dist3(landmarks[tip], wrist);
    const dp=dist3(landmarks[pip], wrist);
    return dt > dp*1.12;
  }
  const thumbExt=extended(4,2);
  const indexExt=extended(8,6);
  const middleExt=extended(12,10);
  const ringExt=extended(16,14);
  const pinkyExt=extended(20,18);
  const extCount=[thumbExt,indexExt,middleExt,ringExt,pinkyExt].filter(Boolean).length;

  const dTI=dist3(landmarks[4], landmarks[8]) / handSize;
  const dTM=dist3(landmarks[4], landmarks[12]) / handSize;
  const dIM=dist3(landmarks[8], landmarks[12]) / handSize;
  const tipWristIdx=dist3(landmarks[8], wrist) / handSize;
  const tipWristMid=dist3(landmarks[12], wrist) / handSize;

  // ✅ 三指捏合：距离近 + 非握拳 + 指尖离手腕不近
  const triPinch = (dTI < 0.32 && dTM < 0.34 && dIM < 0.30)
                && (extCount >= 2)
                && (tipWristIdx > 0.75 && tipWristMid > 0.75);

  const openHand = (extCount >= 4);

  const palm={x:0,y:0,z:0};
  for(const i of [0,5,9,13,17]){ palm.x+=landmarks[i].x; palm.y+=landmarks[i].y; palm.z+=landmarks[i].z; }
  palm.x/=5; palm.y/=5; palm.z/=5;

  const palmClose =
    dist3(landmarks[8],  palm)/handSize < 0.65 &&
    dist3(landmarks[12], palm)/handSize < 0.65 &&
    dist3(landmarks[16], palm)/handSize < 0.70 &&
    dist3(landmarks[20], palm)/handSize < 0.72;

  // ✅ 五指握拳：扩展少 + 指尖靠近掌心 + 排除 triPinch
  const fist = (extCount <= 1) && palmClose && !triPinch;

  return { palm, openHand, fist, triPinch };
}

let prevFist=false, prevOpen=false, prevTri=false;

function onFistStart(){
  // 收拢：只在“边沿”触发一次；且不在收拢态重复换成语
  if(mode !== Mode.MERGE){
    const idiom=pickIdiom();
    rebuildIdiomTargets(idiom);
    for(let i=0;i<ENVELOPES;i++) envHomeLocal[i]=sampleEnvelopeHomeLocal(i);
    setMode(Mode.MERGE);
    statusText.textContent=`收拢态：${idiom}（稳定）`;
  }else{
    statusText.textContent=`收拢态：${currentIdiom}（稳定）`;
  }
}
function onOpenStart(){
  setMode(Mode.SCATTER);
  statusText.textContent = horseReady ? "散开态：PNG 跑马 + 银河环绕（稳定）" : "散开态：PNG 未就绪（检查路径）";
}
function onTriPinchStart(){
  if(mode===Mode.SCATTER) triggerRedPacketFlow();
}

function handleGesture(g){
  if(g.fist && !prevFist) onFistStart();
  if(g.openHand && !prevOpen) onOpenStart();
  if(g.triPinch && !prevTri) onTriPinchStart();
  prevFist=g.fist; prevOpen=g.openHand; prevTri=g.triPinch;
}

async function startHands(){
  if(!window.Hands) throw new Error("MediaPipe Hands missing");
  if(!navigator.mediaDevices?.getUserMedia) throw new Error("getUserMedia unsupported");

  hands=new window.Hands({ locateFile:(f)=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${f}` });
  hands.setOptions({ maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6 });
  hands.onResults((results)=>{
    const lm=results.multiHandLandmarks?.[0] || null;
    if(lm){ lastLandmarks=lm; lastLandmarksTs=performance.now(); }
  });

  const stream=await navigator.mediaDevices.getUserMedia({ audio:false, video:{ facingMode:"user", width:{ideal:640}, height:{ideal:480} } });
  videoEl.srcObject=stream;
  await videoEl.play();

  handEnabled=true;
  led.classList.add("on");
  statusText.textContent = "手势已启用：握拳收拢 / 张开散开 / 三指捏合抓红包";

  let busy=false, lastSent=0;
  async function pump(){
    if(!handEnabled) return;
    const now=performance.now();
    if(!busy && (now-lastSent)>33){
      busy=true; lastSent=now;
      try{ await hands.send({ image: videoEl }); }catch(e){}
      busy=false;
    }
    requestAnimationFrame(pump);
  }
  pump();
}

btnStart.addEventListener("click", async ()=>{
  try{
    btnStart.disabled=true;
    btnStart.textContent="启用中…";
    await startHands();
    btnStart.textContent="手势识别已开启";
  }catch(e){
    statusText.textContent="启用失败：请允许摄像头权限，并确保 HTTPS";
    btnStart.disabled=false;
    btnStart.textContent="启用手势识别";
  }
});

btnHelp.addEventListener("click", ()=>{ tips.style.display = (tips.style.display==="none") ? "flex" : "none"; });

btnReset.addEventListener("click", ()=>{
  const idiom=pickIdiom();
  rebuildIdiomTargets(idiom);

  for(let i=0;i<ENVELOPES;i++){
    envHomeLocal[i]=sampleEnvelopeHomeLocal(i);
    envScatterWorld[i]=sampleScatterWorld();
    envVelWorld[i].set(0,0,0);
  }
  hideFocusOverlay();
  setMode(Mode.MERGE);
  statusText.textContent=`已重置：收拢态（${idiom}）`;
  prevFist=prevOpen=prevTri=false;
});

/* ========= 动画循环 ========= */
let time=0;
let lastTime=performance.now();

function updateMood(dt){
  if(mode===Mode.MERGE){
    bloomPass.strength=damp(bloomPass.strength,1.14,2.8,dt);
    bloomPass.radius  =damp(bloomPass.radius,  0.62,2.8,dt);
    bloomPass.threshold=damp(bloomPass.threshold,0.16,2.8,dt);
    renderer.toneMappingExposure=damp(renderer.toneMappingExposure,1.08,2.2,dt);
  }else if(mode===Mode.SCATTER){
    bloomPass.strength=damp(bloomPass.strength,1.22,2.8,dt);
    bloomPass.radius  =damp(bloomPass.radius,  0.68,2.8,dt);
    bloomPass.threshold=damp(bloomPass.threshold,0.15,2.8,dt);
    renderer.toneMappingExposure=damp(renderer.toneMappingExposure,1.10,2.2,dt);
  }else{
    bloomPass.strength=damp(bloomPass.strength,1.26,2.8,dt);
    bloomPass.radius  =damp(bloomPass.radius,  0.74,2.8,dt);
    bloomPass.threshold=damp(bloomPass.threshold,0.14,2.8,dt);
    renderer.toneMappingExposure=damp(renderer.toneMappingExposure,1.12,2.2,dt);
  }
}

function animate(){
  const now=performance.now();
  const dt=clamp((now-lastTime)/1000, 0, 0.035);
  lastTime=now;
  time += dt;

  if(handEnabled && lastLandmarks && (now-lastLandmarksTs)<180){
    const g=computeGesture(lastLandmarks);
    handleGesture(g);
  }

  mix = damp(mix, targetMix, 2.8, dt);
  targetFocus = (mode===Mode.FOCUS) ? 1 : 0;
  focus = damp(focus, targetFocus, 4.0, dt);
  bloomMixPass.material.uniforms.uBloomIntensity.value = lerp(1.0, 0.34, focus);

  applyCamera(dt, time);
  updateIdiom(dt, time);
  updateEnvelopes(time, dt);
  updateMood(dt);

  camera.layers.set(BLOOM_LAYER);
  bloomComposer.render();
  camera.layers.set(0);
  finalComposer.render();

  requestAnimationFrame(animate);
}

/* ========= Resize ========= */
function onResize(){
  const w=window.innerWidth, h=window.innerHeight;
  camera.aspect=w/h; camera.updateProjectionMatrix();
  renderer.setPixelRatio(Math.min(DPR_CAP, window.devicePixelRatio || 1));
  renderer.setSize(w,h,false);
  bloomComposer.setSize(w,h);
  finalComposer.setSize(w,h);
}
window.addEventListener("resize", onResize);

/* ========= 初始化：先加载 PNG 帧点云，再开始渲染 ========= */
horseVideo.muted=true; horseVideo.loop=true; horseVideo.playsInline=true;

(async ()=>{
  try{
    await buildHorsePointCloudsFromPNGs();
    statusText.textContent = `已加载：收拢态（${currentIdiom}）· 张手散开为 PNG 跑马`;
  }catch(e){
    statusText.textContent = "PNG 跑马加载失败：请检查 HORSE_FRAMES 路径/文件名（大小写也要一致）";
    console.error(e);
  }

  // 红包初始位置
  for(let i=0;i<ENVELOPES;i++) envHomeLocal[i]=sampleEnvelopeHomeLocal(i);

  requestAnimationFrame(animate);
})();
</script>
</body>
</html>
